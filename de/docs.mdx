---
title: "Entwicklerdokumentation"
description: "Kernkonzepte und Funktionen für das IQLabs SDK"
---

<Note>
Dieses Dokument ist in Arbeit und wird weiter verfeinert.
</Note>

## Kernkonzepte

Dies sind die wichtigsten Konzepte, die du kennen solltest, bevor du das IQLabs SDK verwendest.

---

### Datenspeicherung (Code In)

So speicherst du beliebige Daten (Dateien, Text, JSON) on-chain.

#### Wie wird es gespeichert?

Abhängig von der Datengröße wählt das SDK die optimale Methode:

- **Kleine Daten (&lt; 900 Bytes)**: sofort speichern, am schnellsten
- **Mittlere Daten (&lt; 8.5 KB)**: in mehrere Transaktionen aufteilen
- **Große Daten (&gt;= 8.5 KB)**: parallel hochladen für mehr Geschwindigkeit

#### Wichtige zugehörige Funktionen

- [`codeIn()`](#codein): Daten hochladen und eine Transaktions-ID erhalten
- [`readCodeIn()`](#readcodein): Daten anhand einer Transaktions-ID auslesen

---

### Benutzerstatus-PDA

Ein On-Chain-Profilkonto für einen Nutzer.

#### Was wird gespeichert?

- Profilinformationen (Name, Profilbild, Bio usw.)
- Anzahl hochgeladener Dateien
- Einträge zu Freundschaftsanfragen

<Note>
Freundschaftsanfragen werden nicht als Werte im PDA gespeichert; sie werden als Transaktionen gesendet.
</Note>

#### Wann wird es erstellt?

Es wird automatisch erstellt, wenn du [`codeIn()`](#codein) zum ersten Mal aufrufst. Es ist keine zusätzliche Einrichtung erforderlich, aber der erste Nutzer muss möglicherweise zweimal signieren.

---

### Verbindungs-PDA

Ein On-Chain-Konto, das Beziehungen zwischen zwei Nutzern verwaltet (Freunde, Nachrichten usw.).

#### Welche Zustände kann es haben?

- **pending**: Eine Freundschaftsanfrage wurde gesendet, aber noch nicht akzeptiert
- **approved**: Die Anfrage wurde akzeptiert und die Nutzer sind verbunden
- **blocked**: Eine Seite hat die andere blockiert

<Warning>
Eine blockierte Verbindung kann nur von der blockierenden Person aufgehoben werden.
</Warning>

#### Wichtige zugehörige Funktionen

- [`requestConnection()`](#requestconnection): Freundschaftsanfrage senden (erstellt pending)
- [`manageConnection()`](#manageconnection): Anfrage annehmen/ablehnen/blockieren/entsperren
- [`readConnection()`](#readconnection): aktuellen Beziehungsstatus prüfen
- [`writeConnectionRow()`](#writeconnectionrow): Nachrichten/Daten mit einem verbundenen Freund austauschen
- [`fetchUserConnections()`](#fetchuserconnections): alle Verbindungen abrufen (gesendete & empfangene Anfragen)

---

### Datenbanktabellen

JSON-Daten in Tabellen wie in einer Datenbank speichern.

#### Wie werden Tabellen erstellt?

Es gibt keine spezielle "create table"-Funktion. Der erste Schreibvorgang über [`writeRow()`](#writerow) erstellt die Tabelle automatisch.

<Note>
Eine Tabelle wird eindeutig durch die Kombination aus `dbRootId` und `tableSeed` (Tabellenname) identifiziert.
</Note>

#### Wichtige zugehörige Funktionen

- [`writeRow()`](#writerow): eine neue Zeile hinzufügen (erstellt die Tabelle, falls sie fehlt)
- [`readTableRows()`](#readtablerows): Zeilen aus einer Tabelle lesen
- [`getTablelistFromRoot()`](#gettablelistfromroot): alle Tabellen in einer Datenbank auflisten
- [`fetchInventoryTransactions()`](#fetchinventorytransactions): hochgeladene Dateien auflisten

---

## Funktionsdetails

### Datenspeicherung und -abruf

#### `codeIn()`

| **Parameter** | `connection`: Solana-RPC-Verbindung<br/>`signer`: signierende Wallet<br/>`data`: hochzuladende Daten (einzelner String oder Array)<br/>`mode`: Vertragsmodus (Standard: 'anchor') |
|----------------|--------------------------|
| **Rückgabe** | Transaktionssignatur (string) |

```typescript
import { codeIn } from '@iqlabs-official/solana-sdk';

// Eine einzelne Datei hochladen
const signature = await codeIn(connection, signer, 'Hello, blockchain!');

// Mehrere Dateien hochladen
const multiSig = await codeIn(connection, signer, ['file1.txt', 'file2.txt', 'file3.txt']);
```

---

#### `readCodeIn()`

| **Parameter** | `txSignature`: Transaktionssignatur<br/>`connection`: (optional) Solana-RPC-Verbindung |
|----------------|--------------------------|
| **Rückgabe** | Gespeicherte Daten (string) |

```typescript
import { readCodeIn } from '@iqlabs-official/solana-sdk';

const data = await readCodeIn('5Xg7...', connection);
console.log(data); // 'Hello, blockchain!'
```

---

### Verbindungsverwaltung

#### `requestConnection()`

| **Parameter** | `connection`: Solana-RPC-Verbindung<br/>`signer`: signierende Wallet<br/>`dbRootId`: Datenbank-ID<br/>`partyA`, `partyB`: die zwei zu verbindenden Nutzer<br/>`tableName`: Name der Verbindungstabelle<br/>`columns`: Spaltenliste<br/>`idCol`: ID-Spalte<br/>`extKeys`: Erweiterungsschlüssel |
|----------------|--------------------------|
| **Rückgabe** | Transaktionssignatur (string) |

```typescript
import { requestConnection } from '@iqlabs-official/solana-sdk';

// Eine Freundschaftsanfrage senden
await requestConnection(
  connection, signer, 'my-db',
  myWalletAddress, friendWalletAddress,
  'dm_table', ['message', 'timestamp'], 'message_id', []
);
```

---

#### `manageConnection()`

| **Parameter** | `builder`: InstructionBuilder<br/>`accounts`: `{ db_root, connection_table, signer }`<br/>`args`: `{ db_root_id, connection_seed, new_status }` |
|----------------|--------------------------|
| **Rückgabe** | TransactionInstruction |

```typescript
import { contract } from '@iqlabs-official/solana-sdk';

// Eine Freundschaftsanfrage genehmigen
const approveIx = contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: contract.CONNECTION_STATUS_APPROVED }
);

// Einen Nutzer blockieren
const blockIx = contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: contract.CONNECTION_STATUS_BLOCKED }
);
```

---

#### `readConnection()`

| **Parameter** | `dbRootId`: Datenbank-ID<br/>`walletA`, `walletB`: die beiden zu prüfenden Wallets |
|----------------|--------------------------|
| **Rückgabe** | `{ status: 'pending' \| 'approved' \| 'blocked', requester, blocker }` |

```typescript
import { readConnection } from '@iqlabs-official/solana-sdk';

const { status, requester, blocker } = await readConnection('my-db', walletA, walletB);
console.log(status); // 'pending' | 'approved' | 'blocked'
```

---

#### `writeConnectionRow()`

| **Parameter** | `connection`: Solana-RPC-Verbindung<br/>`signer`: signierende Wallet<br/>`dbRootId`: Datenbank-ID<br/>`connectionSeed`: Verbindungssamen<br/>`rowJson`: JSON-Daten |
|----------------|--------------------------|
| **Rückgabe** | Transaktionssignatur (string) |

```typescript
import { writeConnectionRow } from '@iqlabs-official/solana-sdk';

await writeConnectionRow(
  connection, signer, 'my-db', connectionSeed,
  JSON.stringify({ message_id: '123', message: 'Hello friend!', timestamp: Date.now() })
);
```

---

#### `fetchUserConnections()`

Ruft alle Verbindungen (Freundschaftsanfragen) eines Nutzers ab, indem der Transaktionsverlauf des UserState-PDA analysiert wird. Jede Verbindung enthält ihre `dbRootId`, die angibt, zu welcher App die Verbindung gehört.

| **Parameter** | `userPubkey`: öffentlicher Schlüssel des Nutzers (string oder PublicKey)<br/>`options`: optionale Einstellungen |
|----------------|--------------------------|
| **Optionen** | `limit`: maximale Anzahl an Transaktionen<br/>`before`: Signatur, ab der paginiert wird<br/>`speed`: Rate-Limit-Profil ('light', 'medium', 'heavy', 'extreme')<br/>`mode`: Vertragsmodus (optional) |
| **Rückgabe** | Array von Verbindungsobjekten mit dbRootId, partyA, partyB, status, requester, blocker, timestamp |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { fetchUserConnections } = iqlabs.reader;

// Alle Verbindungen abrufen (über alle Apps!)
const connections = await fetchUserConnections(myPubkey, {
  speed: 'light',  // 6 RPS (Standard)
  limit: 100
});

// Nach App filtern
const solchatConnections = connections.filter(c => c.dbRootId === 'solchat');
const zoConnections = connections.filter(c => c.dbRootId === 'zo-trading');

// Nach Status filtern
const pendingRequests = connections.filter(c => c.status === 'pending');
const friends = connections.filter(c => c.status === 'approved');
const blocked = connections.filter(c => c.status === 'blocked');

// Verbindungsdetails prüfen
connections.forEach(conn => {
  console.log(`App: ${conn.dbRootId}, ${conn.partyA} <-> ${conn.partyB}, status: ${conn.status}`);
});
```

---

### Tabellenverwaltung

#### `writeRow()`

| **Parameter** | `connection`: Solana-RPC-Verbindung<br/>`signer`: signierende Wallet<br/>`dbRootId`: Datenbank-ID<br/>`tableSeed`: Tabellenname<br/>`rowJson`: JSON-Zeilen-Daten |
|----------------|--------------------------|
| **Rückgabe** | Transaktionssignatur (string) |

```typescript
import { writeRow } from '@iqlabs-official/solana-sdk';

// Erste Zeile schreiben, um die Tabelle zu erstellen
await writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 1, name: 'Alice', email: 'alice@example.com'
}));

// Weitere Zeile in dieselbe Tabelle hinzufügen
await writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 2, name: 'Bob', email: 'bob@example.com'
}));
```

---

#### `readTableRows()`

| **Parameters** | `account`: table PDA (PublicKey or string)<br/>`options`: optional settings |
|----------------|--------------------------|
| **Options** | `limit`: max number of rows to fetch<br/>`before`: signature cursor for pagination<br/>`signatures`: pre-collected signature array (skips RPC fetch if provided)<br/>`speed`: rate limit profile ('light', 'medium', 'heavy', 'extreme') |
| **Returns** | `Array<Record<string, unknown>>` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Basic usage
const rows = await iqlabs.reader.readTableRows(tablePda, { limit: 50 });

// Cursor-based pagination
const olderRows = await iqlabs.reader.readTableRows(tablePda, { limit: 50, before: 'sig...' });

// With pre-collected signatures (skips signature fetching, decodes directly)
const sigs = await iqlabs.reader.collectSignatures(tablePda);
const targetIdx = sigs.indexOf('abc123');
const slice = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: slice });
```

---

#### `collectSignatures()`

Collects all (or up to `maxSignatures`) transaction signatures for an account. Lightweight — no transaction decoding, only signature strings. Useful for pagination: fetch the full signature list once, then slice and pass to `readTableRows()`.

| **Parameters** | `account`: table PDA (PublicKey or string)<br/>`maxSignatures`: max number of signatures to collect (optional, fetches all if omitted) |
|----------------|--------------------------|
| **Returns** | `string[]` (signature strings) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Collect all signatures
const allSigs = await iqlabs.reader.collectSignatures(tablePda);

// Collect up to 3000 signatures
const sigs = await iqlabs.reader.collectSignatures(tablePda, 3000);

// Use with readTableRows to read from the middle
const targetIdx = sigs.indexOf('abc123');
const chunk = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: chunk });
```

---

#### `getTablelistFromRoot()`

| **Parameter** | `dbRootId`: Datenbank-ID |
|----------------|--------------------------|
| **Rückgabe** | Tabellenname-Array (string[]) |

```typescript
import { getTablelistFromRoot } from '@iqlabs-official/solana-sdk';

const tables = await getTablelistFromRoot('my-db');
console.log('Table list:', tables);
```

---

#### `fetchInventoryTransactions()`

| **Parameter** | `userPubkey`: öffentlicher Schlüssel des Nutzers<br/>`limit`: Maximum (optional) |
|----------------|--------------------------|
| **Rückgabe** | Transaktions-Array |

```typescript
import { fetchInventoryTransactions } from '@iqlabs-official/solana-sdk';

const myFiles = await fetchInventoryTransactions(myPubkey, 20);
myFiles.forEach(tx => {
  let metadata: { data?: unknown } | null = null;
  try {
    metadata = JSON.parse(tx.metadata);
  } catch {
    metadata = null;
  }

  if (metadata && metadata.data !== undefined) {
    const inlineData = typeof metadata.data === 'string'
      ? metadata.data
      : JSON.stringify(metadata.data);
    console.log(`Inline data: ${inlineData}`);
  } else {
    console.log(`Signature: ${tx.signature}`);
  }
});
```

---

### Umgebungseinstellungen

#### `setRpcUrl()`

| **Parameter** | `url`: Solana-RPC-URL |
|----------------|--------------------------|
| **Rückgabe** | Keine (void) |

```typescript
import { setRpcUrl } from '@iqlabs-official/solana-sdk';

setRpcUrl('https://your-rpc.example.com');
```

---

## Erweiterte Funktionen

<Warning>
Dies sind Low-Level-SDK-Funktionen. Für den typischen Gebrauch nicht nötig, aber hilfreich beim Erstellen eigener Features oder beim Debugging.
</Warning>

### Writer-Funktionen

#### `manageRowData()`

Low-Level-Funktion zur Verwaltung von Zeilendaten in Tabellen.

| **Modul** | `writer` |
|------------|----------|
| **Anwendungsfall** | Benutzerdefinierte Zeilenverwaltung, Batch-Operationen |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { manageRowData } = iqlabs.writer;

await manageRowData(connection, signer, {
  dbRootId: 'my-db',
  tableSeed: 'users',
  operation: 'update',
  rowData: JSON.stringify({ id: 1, name: 'Updated Name' })
});
```

---

### Reader-Funktionen

#### `readUserState()`

Liest den UserState-PDA eines Nutzers.

| **Modul** | `reader` |
|------------|----------|
| **Anwendungsfall** | Profildaten abrufen, Upload-Zählung prüfen |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { readUserState } = iqlabs.reader;

const userState = await readUserState(userPubkey);
console.log('Profile:', userState.profile);
console.log('Upload count:', userState.fileCount);
```

---

#### `readInventoryMetadata()`

Liest Metadaten, die mit dem Inventar des Nutzers (hochgeladene Dateien) verbunden sind.

| **Modul** | `reader` |
|------------|----------|
| **Anwendungsfall** | Nutzerdateien mit Metadaten auflisten, Dateiverwaltung |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { readInventoryMetadata } = iqlabs.reader;

const metadata = await readInventoryMetadata(userPubkey);
metadata.forEach(item => {
  console.log(`File: ${item.name}, Size: ${item.size}, Signature: ${item.signature}`);
});
```

---

#### `getSessionPdaList()`

Ruft eine Liste von Session-PDAs ab.

| **Modul** | `reader` |
|------------|----------|
| **Anwendungsfall** | Sitzungsverwaltung, Nachverfolgung aktiver Sitzungen |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { getSessionPdaList } = iqlabs.reader;

const sessions = await getSessionPdaList(userPubkey);
sessions.forEach(session => {
  console.log(`Session PDA: ${session.pda}, Active: ${session.isActive}`);
});
```

---

### Hilfsfunktionen

#### `deriveDmSeed()`

Leitet einen deterministischen Seed für Direktnachrichten (DM) zwischen zwei Nutzern ab.

| **Modul** | `utils` / `reader` |
|------------|----------|
| **Anwendungsfall** | Konsistente Verbindungs-IDs erstellen, DM-Kanal einrichten |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { deriveDmSeed } = iqlabs.utils;

const seed1 = deriveDmSeed(walletA, walletB);
const seed2 = deriveDmSeed(walletB, walletA);
console.log(seed1 === seed2); // true
```

---

#### `toSeedBytes()`

Konvertiert einen String-Seed in das Byte-Format, das für die PDA-Ableitung erforderlich ist.

| **Modul** | `utils` |
|------------|----------|
| **Anwendungsfall** | Benutzerdefinierte PDA-Ableitung, Low-Level-Seed-Manipulation |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { toSeedBytes } = iqlabs.utils;

const seedString = 'my-custom-seed';
const seedBytes = toSeedBytes(seedString);

const [pda, bump] = PublicKey.findProgramAddressSync(
  [seedBytes, otherSeed],
  programId
);
```
