---
title: "Documentação para desenvolvedores (Python)"
description: "Conceitos e funções principais do SDK Python IQLabs"
---

<Note>
Este documento está em desenvolvimento e será aprimorado.
</Note>

## Instalação

```bash
pip install iqlabs-solana-sdk
```

---

## Conceitos Principais

Estes são os conceitos-chave que você precisa conhecer antes de usar o SDK IQLabs.

---

### Armazenamento de Dados (Code In)

É assim que você armazena qualquer dado (arquivos, texto, JSON) on-chain.

#### Como os dados são armazenados?

Dependendo do tamanho dos dados, o SDK escolhe o método ideal:

- **Dados pequenos (&lt; 850 bytes)**: armazenamento imediato, mais rápido
- **Dados médios (&lt; 8.5 KB)**: divididos em múltiplas transações
- **Dados grandes (&gt;= 8.5 KB)**: upload em paralelo para maior velocidade

#### Funções relacionadas principais

- [`code_in()`](#code_in): enviar dados e obter um ID de transação
- [`read_code_in()`](#read_code_in): ler dados a partir de um ID de transação

---

### PDA de Estado do Usuário

Uma conta de perfil on-chain para um usuário.

#### O que é armazenado?

- Informações do perfil (nome, foto de perfil, bio, etc.)
- Número de arquivos enviados
- Registros de solicitações de amizade

<Note>
As solicitações de amizade não são armazenadas como valores no PDA; elas são enviadas como transações.
</Note>

#### Quando é criado?

É criado automaticamente na primeira vez que você chama [`code_in()`](#code_in). Nenhuma configuração extra é necessária, mas o primeiro usuário pode precisar assinar duas vezes.

---

### PDA de Conexão

Uma conta on-chain que gerencia relacionamentos entre dois usuários (amigos, mensagens, etc.).

#### Quais estados ele pode ter?

- **pending** (pendente): uma solicitação de amizade foi enviada, mas ainda não foi aceita
- **approved** (aprovado): a solicitação foi aceita e os usuários estão conectados
- **blocked** (bloqueado): um lado bloqueou o outro

<Warning>
Uma conexão bloqueada só pode ser desbloqueada por quem bloqueou.
</Warning>

#### Funções relacionadas principais

- [`request_connection()`](#request_connection): enviar uma solicitação de amizade (cria status pendente)
- [`manage_connection()`](#manage_connection): aprovar/rejeitar/bloquear/desbloquear uma solicitação
- [`read_connection()`](#read_connection): verificar o status atual do relacionamento
- [`write_connection_row()`](#write_connection_row): trocar mensagens/dados com um amigo conectado
- [`fetch_user_connections()`](#fetch_user_connections): buscar todas as conexões (solicitações de amizade enviadas e recebidas)

---

### Tabelas de Banco de Dados

Armazene dados JSON em tabelas como um banco de dados.

#### Como as tabelas são criadas?

Não existe uma função dedicada para "criar tabela". A primeira escrita via [`write_row()`](#write_row) cria a tabela automaticamente.

<Note>
Uma tabela é identificada de forma única pela combinação de `db_root_id` e `table_seed` (nome da tabela).
</Note>

#### Funções relacionadas principais

- [`write_row()`](#write_row): adicionar uma nova linha (cria a tabela se não existir)
- [`read_table_rows()`](#read_table_rows): ler linhas de uma tabela
- [`get_tablelist_from_root()`](#get_tablelist_from_root): listar todas as tabelas em um banco de dados
- [`fetch_inventory_transactions()`](#fetch_inventory_transactions): listar arquivos enviados

---

## Detalhes das Funções

### Armazenamento e Recuperação de Dados

#### `code_in()`

| **Parâmetros** | `connection`: AsyncClient RPC Solana<br/>`signer`: Keypair ou WalletSigner<br/>`chunks`: dados para upload (list[str])<br/>`filename`: nome do arquivo opcional (str ou None)<br/>`method`: método de upload (int, padrão: 0)<br/>`filetype`: dica de tipo de arquivo (str, padrão: '')<br/>`on_progress`: callback de progresso opcional (Callable[[int], None]) |
|----------------|--------------------------|
| **Retorno** | Assinatura da transação (str) |

```python
from iqlabs import writer
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair

# Enviar dados
signature = await writer.code_in(connection, signer, ['Hello, blockchain!'])

# Enviar com nome de arquivo
signature = await writer.code_in(connection, signer, ['file contents here'], filename='hello.txt')
```

---

#### `read_code_in()`

| **Parâmetros** | `tx_signature`: assinatura da transação (str)<br/>`speed`: perfil de limite de taxa (opcional, str)<br/>`on_progress`: callback de progresso opcional (Callable[[int], None]) |
|----------------|--------------------------|
| **Retorno** | dict com `metadata` (str) e `data` (str ou None) |

```python
from iqlabs import reader

result = await reader.read_code_in('5Xg7...')
print(result['data'])      # 'Hello, blockchain!'
print(result['metadata'])  # JSON string with file metadata
```

---

### Gerenciamento de Conexões

#### `request_connection()`

| **Parâmetros** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: ID do banco de dados (bytes ou str)<br/>`party_a`: chave pública do primeiro usuário (str)<br/>`party_b`: chave pública do segundo usuário (str)<br/>`table_name`: nome da tabela de conexão (str ou bytes)<br/>`columns`: lista de colunas (list[str ou bytes])<br/>`id_col`: coluna de ID (str ou bytes)<br/>`ext_keys`: chaves de extensão (list[str ou bytes]) |
|----------------|--------------------------|
| **Retorno** | Assinatura da transação (str) |

```python
from iqlabs import writer

await writer.request_connection(
    connection, signer, 'my-db',
    my_wallet_address, friend_wallet_address,
    'dm_table', ['message', 'timestamp'], 'message_id', []
)
```

---

#### `manage_connection()`

<Note>
Não existe um wrapper de alto nível no SDK para esta função. Use o construtor de instruções no nível do contrato diretamente.
</Note>

| **Parâmetros** | `builder`: InstructionBuilder<br/>`accounts`: dict com `db_root`, `connection_table`, `signer`<br/>`args`: dict com `db_root_id`, `connection_seed`, `new_status` |
|----------------|--------------------------|
| **Retorno** | Instruction |

```python
from iqlabs import contract

# Criar um construtor de instruções
builder = contract.create_instruction_builder(contract.get_program_id())

# Aprovar uma solicitação de amizade
approve_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_APPROVED}
)

# Bloquear um usuário
block_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_BLOCKED}
)
```

---

#### `read_connection()`

| **Parâmetros** | `db_root_id`: ID do banco de dados (bytes ou str)<br/>`party_a`: primeira carteira (str)<br/>`party_b`: segunda carteira (str) |
|----------------|--------------------------|
| **Retorno** | dict com `status`, `requester`, `blocker` |

```python
from iqlabs import reader

conn_info = await reader.read_connection('my-db', party_a, party_b)
print(conn_info['status'])  # 'pending' | 'approved' | 'blocked'
```

---

#### `write_connection_row()`

| **Parâmetros** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: ID do banco de dados (bytes ou str)<br/>`connection_seed`: seed de conexão (bytes ou str)<br/>`row_json`: dados JSON (str) |
|----------------|--------------------------|
| **Retorno** | Assinatura da transação (str) |

```python
from iqlabs import writer
import json

await writer.write_connection_row(
    connection, signer, 'my-db', connection_seed,
    json.dumps({"message_id": "123", "message": "Hello friend!", "timestamp": 1234567890})
)
```

---

#### `fetch_user_connections()`

Busca todas as conexões (solicitações de amizade) de um usuário analisando o histórico de transações do PDA UserState. Cada conexão inclui seu `db_root_id`, identificando a qual aplicação a conexão pertence.

| **Parâmetros** | `user_pubkey`: chave pública do usuário (str ou Pubkey)<br/>`limit`: número máximo de transações a buscar (opcional)<br/>`before`: assinatura para paginação (opcional)<br/>`speed`: perfil de limite de taxa (opcional) |
|----------------|--------------------------|
| **Retorno** | Lista de dicts de conexão com db_root_id, connection_pda, party_a, party_b, status, requester, blocker, timestamp |

```python
from iqlabs import reader

# Buscar todas as conexões (de todos os apps!)
connections = await reader.fetch_user_connections(
    my_pubkey,
    speed="light",
    limit=100
)

# Filtrar por status
pending_requests = [c for c in connections if c['status'] == 'pending']
friends = [c for c in connections if c['status'] == 'approved']
blocked = [c for c in connections if c['status'] == 'blocked']

# Verificar detalhes da conexão
for conn in connections:
    print(f"Party A: {conn['party_a']} <-> Party B: {conn['party_b']}, status: {conn['status']}")
```

---

### Gerenciamento de Tabelas

#### `write_row()`

| **Parâmetros** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: ID do banco de dados (bytes ou str)<br/>`table_seed`: nome da tabela (bytes ou str)<br/>`row_json`: dados JSON da linha (str)<br/>`skip_confirmation`: pular confirmação da tx (padrão: False) |
|----------------|--------------------------|
| **Retorno** | Assinatura da transação (str) |

```python
from iqlabs import writer
import json

# Escrever a primeira linha para criar a tabela
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 1, "name": "Alice", "email": "alice@example.com"
}))

# Adicionar outra linha na mesma tabela
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 2, "name": "Bob", "email": "bob@example.com"
}))
```

---

#### `read_table_rows()`

| **Parâmetros** | `account`: PDA da tabela (Pubkey ou str)<br/>`before`: cursor de assinatura para paginação (opcional)<br/>`limit`: número máximo de linhas a buscar (opcional)<br/>`speed`: perfil de limite de taxa (opcional) |
|----------------|--------------------------|
| **Retorno** | `list[dict]` |

```python
from iqlabs import reader

# Uso básico
rows = await reader.read_table_rows(table_pda, limit=50)

# Paginação baseada em cursor
older_rows = await reader.read_table_rows(table_pda, limit=50, before="sig...")
```

---

#### `get_tablelist_from_root()`

| **Parâmetros** | `connection`: AsyncClient<br/>`db_root_id`: ID do banco de dados (bytes ou str) |
|----------------|--------------------------|
| **Retorno** | dict com `root_pda`, `creator`, `table_seeds`, `global_table_seeds` |

```python
from iqlabs import reader

result = await reader.get_tablelist_from_root(connection, 'my-db')
print('Creator:', result['creator'])
print('Table seeds:', result['table_seeds'])
```

---

#### `fetch_inventory_transactions()`

| **Parâmetros** | `public_key`: chave pública do usuário (Pubkey)<br/>`limit`: quantidade máxima (int)<br/>`before`: cursor de paginação (opcional, str) |
|----------------|--------------------------|
| **Retorno** | Lista de transações |

```python
from iqlabs import reader
from solders.pubkey import Pubkey
import json

my_files = await reader.fetch_inventory_transactions(my_pubkey, 20)
for tx in my_files:
    metadata = None
    try:
        metadata = json.loads(tx['metadata'])
    except:
        metadata = None

    if metadata and 'data' in metadata:
        inline_data = metadata['data'] if isinstance(metadata['data'], str) else json.dumps(metadata['data'])
        print(f"Inline data: {inline_data}")
    else:
        print(f"Signature: {tx['signature']}")
```

---

### Configurações de Ambiente

#### `set_rpc_url()`

| **Parâmetros** | `url`: URL RPC Solana (str) |
|----------------|--------------------------|
| **Retorno** | None |

```python
from iqlabs import set_rpc_url

set_rpc_url('https://your-rpc.example.com')
```

---

## Funções Avançadas

<Warning>
Estas são funções de baixo nível do SDK. Não são necessárias para uso típico, mas são úteis ao construir funcionalidades personalizadas ou depurar.
</Warning>

### Funções de Escrita

#### `manage_row_data()`

Função unificada que lida tanto com escritas de linhas em tabelas quanto com escritas de linhas de conexão. Detecta automaticamente se deve escrever em uma tabela ou conexão com base nos PDAs existentes.

| **Módulo** | `writer` |
|------------|----------|
| **Parâmetros** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: ID do banco de dados (bytes ou str)<br/>`seed`: seed da tabela ou conexão (bytes ou str)<br/>`row_json`: dados JSON da linha (str)<br/>`table_name`: obrigatório para edições de tabela (opcional)<br/>`target_tx`: tx de referência para edições de tabela (opcional) |
| **Retorno** | Assinatura da transação (str) |
| **Caso de Uso** | Gerenciamento personalizado de linhas, atualização de linhas existentes |

```python
from iqlabs import writer
import json

await writer.manage_row_data(
    connection, signer,
    'my-db',       # db_root_id
    'users',       # seed (table seed)
    json.dumps({"id": 1, "name": "Updated Name"}),
    table_name='users',
    target_tx=original_tx_sig
)
```

---

### Funções de Leitura

#### `read_user_state()`

Lê o PDA UserState de um determinado usuário.

| **Módulo** | `reader` |
|------------|----------|
| **Parâmetros** | `user_pubkey`: chave pública do usuário (str) |
| **Retorno** | dict com `owner`, `metadata`, `total_session_files`, `profile_data` |
| **Caso de Uso** | Buscar dados do perfil do usuário, verificar contagem de uploads |

```python
from iqlabs import reader

user_state = await reader.read_user_state(user_pubkey)
print('Owner:', user_state['owner'])
print('Session files:', user_state['total_session_files'])
print('Profile data:', user_state['profile_data'])
```

---

#### `read_inventory_metadata()`

Lê os metadados associados a uma transação de inventário do usuário.

| **Módulo** | `reader` |
|------------|----------|
| **Parâmetros** | `tx_signature`: assinatura da transação (str) |
| **Retorno** | dict com metadados |
| **Caso de Uso** | Extrair metadados de arquivos de transações de inventário |

```python
from iqlabs import reader

result = await reader.read_inventory_metadata(tx_signature)
print('Metadata:', result)
```

---

#### `get_session_pda_list()`

Recupera uma lista de endereços de PDA de sessão para um usuário.

| **Módulo** | `reader` |
|------------|----------|
| **Parâmetros** | `user_pubkey`: chave pública do usuário (str) |
| **Retorno** | `list[str]` (strings base58 de PDA de sessão) |
| **Caso de Uso** | Gerenciamento de sessões, rastreamento de sessões ativas |

```python
from iqlabs import reader

sessions = await reader.get_session_pda_list(user_pubkey)
for pda in sessions:
    print(f"Session PDA: {pda}")
```

---

#### Funções de PDA do Contrato

Funções de derivação de PDA de baixo nível disponíveis no módulo `contract`.

| **Módulo** | `contract` |
|------------|----------|
| **Caso de Uso** | Derivação personalizada de PDA, consulta de contas |

```python
from iqlabs import contract
from solders.pubkey import Pubkey

program_id = contract.get_program_id()
db_root_pda = contract.get_db_root_pda(db_root_id, program_id)
table_pda = contract.get_table_pda(db_root_pda, table_seed, program_id)
user_pda = contract.get_user_pda(user_pubkey, program_id)
session_pda = contract.get_session_pda(user_pubkey, seq=0, program_id=program_id)
connection_pda = contract.get_connection_table_pda(db_root_pda, connection_seed, program_id)
```

---

### Funções Utilitárias

#### `derive_dm_seed()`

Deriva uma seed determinística para mensagens diretas (DM) entre dois usuários. Ordena as duas chaves públicas alfabeticamente e aplica o hash `"menor:maior"` com Keccak-256.

| **Módulo** | `utils` |
|------------|----------|
| **Parâmetros** | `user_a`: chave pública do primeiro usuário (str)<br/>`user_b`: chave pública do segundo usuário (str) |
| **Retorno** | bytes (seed de 32 bytes) |
| **Caso de Uso** | Criar identificadores de conexão consistentes, configuração de canal de DM |

```python
from iqlabs.sdk.utils.seed import derive_dm_seed

seed1 = derive_dm_seed(wallet_a, wallet_b)
seed2 = derive_dm_seed(wallet_b, wallet_a)
print(seed1 == seed2)  # True — a ordem não importa
```

---

#### `to_seed_bytes()`

Converte um identificador de seed para bytes. Se a entrada for uma string hexadecimal de 64 caracteres, ela passa diretamente. Caso contrário, aplica o hash Keccak-256.

| **Módulo** | `utils` |
|------------|----------|
| **Parâmetros** | `value`: string ou bytes da seed |
| **Retorno** | bytes |
| **Caso de Uso** | Derivação personalizada de PDA, manipulação de seed de baixo nível |

```python
from iqlabs.sdk.utils.seed import to_seed_bytes
from solders.pubkey import Pubkey

seed_string = 'my-custom-seed'
seed_bytes = to_seed_bytes(seed_string)

pda, bump = Pubkey.find_program_address(
    [seed_bytes, other_seed],
    program_id
)
```

---
