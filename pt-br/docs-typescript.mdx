---
title: "Documentação para desenvolvedores"
description: "Conceitos e funções principais para o SDK da IQLabs"
---

<Note>
Este documento está em andamento e será refinado.
</Note>

## Instalação

```bash
npm i @iqlabs-official/solana-sdk
```

---

## Conceitos principais

Estes são os conceitos principais que você precisa conhecer antes de usar o SDK da IQLabs.

---

### Armazenamento de dados (Code In)

É assim que você armazena qualquer dado (arquivos, texto, JSON) on-chain.

#### Como é armazenado?

Dependendo do tamanho dos dados, o SDK escolhe o método ideal:

- **Dados pequenos (&lt; 900 bytes)**: armazenar imediatamente, mais rápido
- **Dados médios (&lt; 8.5 KB)**: dividir em várias transações
- **Dados grandes (&gt;= 8.5 KB)**: enviar em paralelo para mais velocidade

#### Funções principais relacionadas

- [`codeIn()`](#codein): enviar dados e obter um ID de transação
- [`readCodeIn()`](#readcodein): ler dados a partir de um ID de transação

---

### PDA de estado do usuário

Uma conta de perfil on-chain para um usuário.

#### O que é armazenado?

- Informações de perfil (nome, foto de perfil, bio, etc.)
- Número de arquivos enviados
- Registros de solicitações de amizade

<Note>
Solicitações de amizade não são armazenadas como valores no PDA; elas são enviadas como transações.
</Note>

#### Quando é criado?

É criado automaticamente na primeira vez que você chama [`codeIn()`](#codein). Nenhuma configuração extra é necessária, mas o primeiro usuário pode precisar assinar duas vezes.

---

### PDA de conexão

Uma conta on-chain que gerencia relacionamentos entre dois usuários (amigos, mensagens, etc.).

#### Quais estados pode ter?

- **pending**: uma solicitação de amizade foi enviada, mas ainda não foi aceita
- **approved**: a solicitação foi aceita e os usuários estão conectados
- **blocked**: um lado bloqueou o outro

<Warning>
Uma conexão bloqueada só pode ser desbloqueada por quem bloqueou.
</Warning>

#### Funções principais relacionadas

- [`requestConnection()`](#requestconnection): enviar uma solicitação de amizade (cria pending)
- [`manageConnection()`](#manageconnection): aprovar/rejeitar/bloquear/desbloquear uma solicitação
- [`readConnection()`](#readconnection): verificar o status atual do relacionamento
- [`writeConnectionRow()`](#writeconnectionrow): trocar mensagens/dados com um amigo conectado
- [`fetchUserConnections()`](#fetchuserconnections): buscar todas as conexões (solicitações enviadas e recebidas)

---

### Tabelas de banco de dados

Armazene dados JSON em tabelas como um banco de dados.

#### Como as tabelas são criadas?

Não existe uma função dedicada de "criar tabela". A primeira gravação via [`writeRow()`](#writerow) cria a tabela automaticamente.

<Note>
Uma tabela é identificada de forma única pela combinação de `dbRootId` e `tableSeed` (nome da tabela).
</Note>

#### Funções principais relacionadas

- [`writeRow()`](#writerow): adicionar uma nova linha (cria a tabela se não existir)
- [`readTableRows()`](#readtablerows): ler linhas de uma tabela
- [`getTablelistFromRoot()`](#gettablelistfromroot): listar todas as tabelas de um banco de dados
- [`fetchInventoryTransactions()`](#fetchinventorytransactions): listar arquivos enviados

---

## Detalhes das funções

### Armazenamento e recuperação de dados

#### `codeIn()`

| **Parâmetros** | `input`: objeto `{ connection, signer }`<br/>`data`: dados para envio (string ou string[])<br/>`filename`: nome do arquivo opcional (string)<br/>`method`: método de envio (number, padrão: 0)<br/>`filetype`: dica de tipo de arquivo (string, padrão: '')<br/>`onProgress`: callback de progresso opcional `(percent: number) => void` |
|----------------|--------------------------|
| **Retorna** | Assinatura da transação (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Enviar dados
const signature = await iqlabs.writer.codeIn(
  { connection, signer },
  'Hello, blockchain!'
);

// Enviar com nome de arquivo
const sig = await iqlabs.writer.codeIn(
  { connection, signer },
  'file contents here',
  'hello.txt'
);
```

---

#### `readCodeIn()`

| **Parâmetros** | `txSignature`: assinatura da transação (string)<br/>`speed`: perfil de limite de taxa (opcional, 'light' \| 'medium' \| 'heavy' \| 'extreme')<br/>`onProgress`: callback de progresso opcional `(percent: number) => void` |
|----------------|--------------------------|
| **Retorna** | `{ metadata: string, data: string \| null }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.readCodeIn('5Xg7...');
console.log(result.data);      // 'Hello, blockchain!'
console.log(result.metadata);  // String JSON com metadados do arquivo
```

---

### Gerenciamento de conexões

#### `requestConnection()`

| **Parâmetros** | `connection`: conexão RPC Solana<br/>`signer`: Signer<br/>`dbRootId`: ID do banco de dados (Uint8Array ou string)<br/>`partyA`: chave pública do primeiro usuário (string)<br/>`partyB`: chave pública do segundo usuário (string)<br/>`tableName`: nome da tabela de conexão (string ou Uint8Array)<br/>`columns`: lista de colunas (Array\<string \| Uint8Array\>)<br/>`idCol`: coluna de ID (string ou Uint8Array)<br/>`extKeys`: chaves de extensão (Array\<string \| Uint8Array\>) |
|----------------|--------------------------|
| **Retorna** | Assinatura da transação (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.requestConnection(
  connection, signer, 'my-db',
  myWalletAddress, friendWalletAddress,
  'dm_table', ['message', 'timestamp'], 'message_id', []
);
```

---

#### `manageConnection()`

<Note>
Não há um wrapper de alto nível no SDK para esta função. Use o construtor de instruções no nível do contrato diretamente.
</Note>

| **Parâmetros** | `builder`: InstructionBuilder<br/>`accounts`: `{ db_root, connection_table, signer }` (PublicKey)<br/>`args`: `{ db_root_id, connection_seed, new_status }` |
|----------------|--------------------------|
| **Retorna** | TransactionInstruction |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const builder = iqlabs.contract.createInstructionBuilder(iqlabs.contract.PROGRAM_ID);

// Aprovar uma solicitação de amizade
const approveIx = iqlabs.contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: iqlabs.contract.CONNECTION_STATUS_APPROVED }
);

// Bloquear um usuário
const blockIx = iqlabs.contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: iqlabs.contract.CONNECTION_STATUS_BLOCKED }
);
```

---

#### `readConnection()`

| **Parâmetros** | `dbRootId`: ID do banco de dados (Uint8Array ou string)<br/>`partyA`: primeira carteira (string)<br/>`partyB`: segunda carteira (string) |
|----------------|--------------------------|
| **Retorna** | `{ status: 'pending' \| 'approved' \| 'blocked' \| 'unknown', requester: 'a' \| 'b', blocker: 'a' \| 'b' \| 'none' }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const { status, requester, blocker } = await iqlabs.reader.readConnection('my-db', partyA, partyB);
console.log(status); // 'pending' | 'approved' | 'blocked'
```

---

#### `writeConnectionRow()`

| **Parâmetros** | `connection`: conexão RPC Solana<br/>`signer`: Signer<br/>`dbRootId`: ID do banco de dados (Uint8Array ou string)<br/>`connectionSeed`: semente de conexão (Uint8Array ou string)<br/>`rowJson`: dados JSON (string) |
|----------------|--------------------------|
| **Retorna** | Assinatura da transação (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.writeConnectionRow(
  connection, signer, 'my-db', connectionSeed,
  JSON.stringify({ message_id: '123', message: 'Hello friend!', timestamp: Date.now() })
);
```

---

#### `fetchUserConnections()`

Busca todas as conexões (solicitações de amizade) de um usuário analisando o histórico de transações do PDA UserState. Cada conexão inclui seu `dbRootId`, identificando a qual app a conexão pertence.

| **Parâmetros** | `userPubkey`: chave pública do usuário (string ou PublicKey)<br/>`options`: configurações opcionais |
|----------------|--------------------------|
| **Opções** | `limit`: número máximo de transações para buscar<br/>`before`: assinatura para paginar a partir de<br/>`speed`: perfil de limite de taxa ('light' \| 'medium' \| 'heavy' \| 'extreme') |
| **Retorna** | Array de `{ dbRootId, connectionPda, partyA, partyB, status, requester, blocker, timestamp }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const connections = await iqlabs.reader.fetchUserConnections(myPubkey, {
  speed: 'light',
  limit: 100
});

// Filtrar por status
const pendingRequests = connections.filter(c => c.status === 'pending');
const friends = connections.filter(c => c.status === 'approved');
const blocked = connections.filter(c => c.status === 'blocked');

// Verificar detalhes da conexão
connections.forEach(conn => {
  console.log(`${conn.partyA} <-> ${conn.partyB}, status: ${conn.status}`);
});
```

---

### Gerenciamento de tabelas

#### `writeRow()`

| **Parâmetros** | `connection`: conexão RPC Solana<br/>`signer`: Signer<br/>`dbRootId`: ID do banco de dados (Uint8Array ou string)<br/>`tableSeed`: nome da tabela (Uint8Array ou string)<br/>`rowJson`: dados JSON da linha (string)<br/>`skipConfirmation`: pular confirmação da transação (boolean, padrão: false) |
|----------------|--------------------------|
| **Retorna** | Assinatura da transação (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Escrever a primeira linha para criar a tabela
await iqlabs.writer.writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 1, name: 'Alice', email: 'alice@example.com'
}));

// Adicionar outra linha à mesma tabela
await iqlabs.writer.writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 2, name: 'Bob', email: 'bob@example.com'
}));
```

---

#### `readTableRows()`

| **Parâmetros** | `account`: PDA da tabela (PublicKey ou string)<br/>`options`: configurações opcionais |
|----------------|--------------------------|
| **Opções** | `limit`: número máximo de linhas para buscar<br/>`before`: cursor de assinatura para paginação<br/>`signatures`: array de assinaturas pré-coletadas (ignora busca RPC se fornecido)<br/>`speed`: perfil de limite de taxa ('light', 'medium', 'heavy', 'extreme') |
| **Retorna** | `Array<Record<string, unknown>>` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Uso básico
const rows = await iqlabs.reader.readTableRows(tablePda, { limit: 50 });

// Paginação baseada em cursor
const olderRows = await iqlabs.reader.readTableRows(tablePda, { limit: 50, before: 'sig...' });

// Com assinaturas pré-coletadas (ignora busca de assinaturas, decodifica diretamente)
const sigs = await iqlabs.reader.collectSignatures(tablePda);
const targetIdx = sigs.indexOf('abc123');
const slice = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: slice });
```

---

#### `collectSignatures()`

Coleta todas (ou até `maxSignatures`) assinaturas de transação de uma conta. Leve -- sem decodificação de transações, apenas strings de assinatura. Útil para paginação: busque a lista completa de assinaturas uma vez, depois fatie e passe para `readTableRows()`.

| **Parâmetros** | `account`: PDA da tabela (PublicKey ou string)<br/>`maxSignatures`: número máximo de assinaturas para coletar (opcional, busca todas se omitido) |
|----------------|--------------------------|
| **Retorna** | `string[]` (strings de assinatura) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Coletar todas as assinaturas
const allSigs = await iqlabs.reader.collectSignatures(tablePda);

// Coletar até 3000 assinaturas
const sigs = await iqlabs.reader.collectSignatures(tablePda, 3000);

// Usar com readTableRows para ler a partir do meio
const targetIdx = sigs.indexOf('abc123');
const chunk = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: chunk });
```

---

#### `getTablelistFromRoot()`

| **Parâmetros** | `connection`: conexão RPC Solana<br/>`dbRootId`: ID do banco de dados (Uint8Array ou string) |
|----------------|--------------------------|
| **Retorna** | `{ rootPda: PublicKey, creator: string \| null, tableSeeds: string[], globalTableSeeds: string[] }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.getTablelistFromRoot(connection, 'my-db');
console.log('Creator:', result.creator);
console.log('Table seeds:', result.tableSeeds);
```

---

#### `fetchInventoryTransactions()`

| **Parâmetros** | `publicKey`: chave pública do usuário (PublicKey)<br/>`limit`: quantidade máxima (number)<br/>`before`: cursor de paginação (opcional, string) |
|----------------|--------------------------|
| **Retorna** | Array de transações |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const myFiles = await iqlabs.reader.fetchInventoryTransactions(myPubkey, 20);
myFiles.forEach(tx => {
  let metadata: { data?: unknown } | null = null;
  try {
    metadata = JSON.parse(tx.metadata);
  } catch {
    metadata = null;
  }

  if (metadata && metadata.data !== undefined) {
    const inlineData = typeof metadata.data === 'string'
      ? metadata.data
      : JSON.stringify(metadata.data);
    console.log(`Inline data: ${inlineData}`);
  } else {
    console.log(`Signature: ${tx.signature}`);
  }
});
```

---

### Configurações de ambiente

#### `setRpcUrl()`

| **Parâmetros** | `url`: URL de RPC Solana (string) |
|----------------|--------------------------|
| **Retorna** | void |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

iqlabs.utils.setRpcUrl('https://your-rpc.example.com');
```

---

## Funções avançadas

<Warning>
Estas são funções de baixo nível do SDK. Não são necessárias para uso típico, mas são úteis ao criar recursos personalizados ou depurar.
</Warning>

### Funções de escrita

#### `manageRowData()`

Função unificada que lida com gravações de linhas em tabelas e gravações de linhas em conexões. Detecta automaticamente se deve gravar em uma tabela ou conexão com base nos PDAs existentes.

| **Módulo** | `writer` |
|------------|----------|
| **Parâmetros** | `connection`: conexão RPC Solana<br/>`signer`: Signer<br/>`dbRootId`: ID do banco de dados (Uint8Array ou string)<br/>`seed`: semente da tabela ou conexão (Uint8Array ou string)<br/>`rowJson`: dados JSON da linha (string)<br/>`tableName`: obrigatório para edições em tabelas (opcional, string ou Uint8Array)<br/>`targetTx`: transação de referência para edições em tabelas (opcional, string ou Uint8Array) |
| **Retorna** | Assinatura da transação (string) |
| **Caso de uso** | Gerenciamento personalizado de linhas, atualização de linhas existentes |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.manageRowData(
  connection, signer,
  'my-db',       // dbRootId
  'users',       // seed (semente da tabela)
  JSON.stringify({ id: 1, name: 'Updated Name' }),
  'users',       // tableName
  originalTxSig  // targetTx
);
```

---

### Funções de leitura

#### `readUserState()`

Lê o PDA UserState de um usuário.

| **Módulo** | `reader` |
|------------|----------|
| **Parâmetros** | `userPubkey`: chave pública do usuário (string) |
| **Retorna** | `{ owner: string, metadata: string \| null, totalSessionFiles: bigint, profileData?: string }` |
| **Caso de uso** | Buscar dados de perfil, conferir contagens de upload |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const userState = await iqlabs.reader.readUserState(userPubkey);
console.log('Owner:', userState.owner);
console.log('Session files:', userState.totalSessionFiles);
console.log('Profile data:', userState.profileData);
```

---

#### `readInventoryMetadata()`

Lê os metadados associados à transação de inventário de um usuário.

| **Módulo** | `reader` |
|------------|----------|
| **Parâmetros** | `txSignature`: assinatura da transação (string) |
| **Retorna** | `{ onChainPath: string, metadata: string }` |
| **Caso de uso** | Extrair metadados de arquivos de transações de inventário |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.readInventoryMetadata(txSignature);
console.log('Path:', result.onChainPath);
console.log('Metadata:', result.metadata);
```

---

#### `getSessionPdaList()`

Recupera uma lista de endereços PDA de sessão de um usuário.

| **Módulo** | `reader` |
|------------|----------|
| **Parâmetros** | `userPubkey`: chave pública do usuário (string) |
| **Retorna** | `string[]` (strings base58 de PDAs de sessão) |
| **Caso de uso** | Gerenciamento de sessões, acompanhamento de sessões ativas |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const sessions = await iqlabs.reader.getSessionPdaList(userPubkey);
sessions.forEach(pda => {
  console.log(`Session PDA: ${pda}`);
});
```

---

### Funções utilitárias

#### `deriveDmSeed()`

Deriva uma semente determinística para mensagens diretas (DM) entre dois usuários. Ordena as duas chaves públicas alfabeticamente e aplica hash com keccak256.

| **Módulo** | `utils` |
|------------|----------|
| **Parâmetros** | `userA`: chave pública do primeiro usuário (string)<br/>`userB`: chave pública do segundo usuário (string) |
| **Retorna** | `Uint8Array` (bytes da semente) |
| **Caso de uso** | Criar identificadores de conexão consistentes, configuração de canal DM |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const seed1 = iqlabs.utils.deriveDmSeed(walletA, walletB);
const seed2 = iqlabs.utils.deriveDmSeed(walletB, walletA);
// seed1 e seed2 são idênticos — a ordem não importa
```

---

#### `toSeedBytes()`

Converte um identificador de semente para bytes. Se a entrada for uma string hexadecimal de 64 caracteres, retorna os bytes hex diretamente. Caso contrário, aplica hash keccak256.

| **Módulo** | `utils` |
|------------|----------|
| **Parâmetros** | `value`: string ou Uint8Array da semente |
| **Retorna** | `Uint8Array` |
| **Caso de uso** | Derivação personalizada de PDA, manipulação de sementes de baixo nível |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const seedString = 'my-custom-seed';
const seedBytes = iqlabs.utils.toSeedBytes(seedString);

const [pda, bump] = PublicKey.findProgramAddressSync(
  [seedBytes, otherSeed],
  programId
);
```
