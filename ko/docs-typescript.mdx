---
title: "개발자 문서"
description: "IQLabs SDK의 핵심 개념과 함수"
---

<Note>
이 문서는 작성 중이며 계속 업데이트될 예정입니다.
</Note>

## 설치

```bash
npm i @iqlabs-official/solana-sdk
```

---

## 핵심 개념

IQLabs SDK를 사용하기 전에 알아야 할 주요 개념들입니다.

---

### 데이터 저장 (Code In)

파일, 텍스트, JSON 등 모든 데이터를 온체인에 저장하는 방법입니다.

#### 어떻게 저장되나요?

데이터 크기에 따라 SDK가 최적의 방법을 자동으로 선택합니다:

- **작은 데이터 (&lt; 900 bytes)**: 즉시 저장, 가장 빠름
- **중간 데이터 (&lt; 8.5 KB)**: 여러 트랜잭션으로 분할
- **큰 데이터 (&gt;= 8.5 KB)**: 속도를 위해 병렬 업로드

#### 관련 주요 함수

- [`codeIn()`](#codein): 데이터를 업로드하고 트랜잭션 ID를 받음
- [`readCodeIn()`](#readcodein): 트랜잭션 ID로 데이터를 다시 읽음

---

### User State PDA

사용자를 위한 온체인 프로필 계정입니다.

#### 무엇이 저장되나요?

- 프로필 정보 (이름, 프로필 사진, 소개 등)
- 업로드한 파일 수
- 친구 요청 기록

<Note>
친구 요청은 PDA에 값으로 저장되지 않고 트랜잭션으로 전송됩니다.
</Note>

#### 언제 생성되나요?

[`codeIn()`](#codein)을 처음 호출할 때 자동으로 생성됩니다. 추가 설정이 필요 없지만, 처음 사용자는 두 번 서명해야 할 수 있습니다.

---

### Connection PDA

두 사용자 간의 관계(친구, 메시지 등)를 관리하는 온체인 계정입니다.

#### 어떤 상태가 있나요?

- **pending**: 친구 요청이 전송되었지만 아직 수락되지 않음
- **approved**: 요청이 수락되고 사용자들이 연결됨
- **blocked**: 한쪽이 다른 쪽을 차단함

<Warning>
차단된 연결은 차단한 사람만 해제할 수 있습니다.
</Warning>

#### 관련 주요 함수

- [`requestConnection()`](#requestconnection): 친구 요청 보내기 (pending 생성)
- [`manageConnection()`](#manageconnection): 요청 승인/거절/차단/해제
- [`readConnection()`](#readconnection): 현재 관계 상태 확인
- [`writeConnectionRow()`](#writeconnectionrow): 연결된 친구와 메시지/데이터 교환
- [`fetchUserConnections()`](#fetchuserconnections): 모든 연결 조회 (보낸/받은 친구 요청)

---

### 데이터베이스 테이블

데이터베이스처럼 테이블에 JSON 데이터를 저장합니다.

#### 테이블은 어떻게 생성되나요?

전용 "테이블 생성" 함수가 없습니다. [`writeRow()`](#writerow)를 통한 첫 번째 쓰기가 자동으로 테이블을 생성합니다.

<Note>
테이블은 `dbRootId`와 `tableSeed` (테이블 이름)의 조합으로 고유하게 식별됩니다.
</Note>

#### 관련 주요 함수

- [`writeRow()`](#writerow): 새 행 추가 (테이블이 없으면 생성)
- [`readTableRows()`](#readtablerows): 테이블에서 행 읽기
- [`getTablelistFromRoot()`](#gettablelistfromroot): 데이터베이스의 모든 테이블 목록 조회
- [`fetchInventoryTransactions()`](#fetchinventorytransactions): 업로드한 파일 목록 조회

---

## 함수 상세

### 데이터 저장 및 조회

#### `codeIn()`

| **파라미터** | `input`: `{ connection, signer }` 객체<br/>`data`: 업로드할 데이터 (string 또는 string[])<br/>`filename`: 파일 이름 (선택, string)<br/>`method`: 업로드 방식 (number, 기본값: 0)<br/>`filetype`: 파일 유형 힌트 (string, 기본값: '')<br/>`onProgress`: 진행률 콜백 (선택) `(percent: number) => void` |
|-------------|--------------------------|
| **반환값** | 트랜잭션 서명 (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 데이터 업로드
const signature = await iqlabs.writer.codeIn(
  { connection, signer },
  'Hello, blockchain!'
);

// 파일 이름과 함께 업로드
const sig = await iqlabs.writer.codeIn(
  { connection, signer },
  'file contents here',
  'hello.txt'
);
```

---

#### `readCodeIn()`

| **파라미터** | `txSignature`: 트랜잭션 서명 (string)<br/>`speed`: 속도 제한 프로필 (선택, 'light' \| 'medium' \| 'heavy' \| 'extreme')<br/>`onProgress`: 진행률 콜백 (선택) `(percent: number) => void` |
|-------------|--------------------------|
| **반환값** | `{ metadata: string, data: string \| null }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.readCodeIn('5Xg7...');
console.log(result.data);      // 'Hello, blockchain!'
console.log(result.metadata);  // 파일 메타데이터가 포함된 JSON 문자열
```

---

### 연결 관리

#### `requestConnection()`

| **파라미터** | `connection`: Solana RPC 연결<br/>`signer`: 서명 지갑<br/>`dbRootId`: 데이터베이스 ID (Uint8Array 또는 string)<br/>`partyA`: 첫 번째 사용자 공개키 (string)<br/>`partyB`: 두 번째 사용자 공개키 (string)<br/>`tableName`: 연결 테이블 이름 (string 또는 Uint8Array)<br/>`columns`: 컬럼 목록 (Array\<string \| Uint8Array\>)<br/>`idCol`: ID 컬럼 (string 또는 Uint8Array)<br/>`extKeys`: 확장 키 (Array\<string \| Uint8Array\>) |
|-------------|--------------------------|
| **반환값** | 트랜잭션 서명 (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.requestConnection(
  connection, signer, 'my-db',
  myWalletAddress, friendWalletAddress,
  'dm_table', ['message', 'timestamp'], 'message_id', []
);
```

---

#### `manageConnection()`

<Note>
이 함수에 대한 고수준 SDK 래퍼가 없습니다. 컨트랙트 수준의 인스트럭션 빌더를 직접 사용하세요.
</Note>

| **파라미터** | `builder`: InstructionBuilder<br/>`accounts`: `{ db_root, connection_table, signer }` (PublicKey)<br/>`args`: `{ db_root_id, connection_seed, new_status }` |
|-------------|--------------------------|
| **반환값** | TransactionInstruction |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const builder = iqlabs.contract.createInstructionBuilder(iqlabs.contract.PROGRAM_ID);

// 친구 요청 승인
const approveIx = iqlabs.contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: iqlabs.contract.CONNECTION_STATUS_APPROVED }
);

// 사용자 차단
const blockIx = iqlabs.contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: iqlabs.contract.CONNECTION_STATUS_BLOCKED }
);
```

---

#### `readConnection()`

| **파라미터** | `dbRootId`: 데이터베이스 ID (Uint8Array 또는 string)<br/>`partyA`: 첫 번째 지갑 (string)<br/>`partyB`: 두 번째 지갑 (string) |
|-------------|--------------------------|
| **반환값** | `{ status: 'pending' \| 'approved' \| 'blocked' \| 'unknown', requester: 'a' \| 'b', blocker: 'a' \| 'b' \| 'none' }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const { status, requester, blocker } = await iqlabs.reader.readConnection('my-db', partyA, partyB);
console.log(status); // 'pending' | 'approved' | 'blocked'
```

---

#### `writeConnectionRow()`

| **파라미터** | `connection`: Solana RPC 연결<br/>`signer`: 서명 지갑<br/>`dbRootId`: 데이터베이스 ID (Uint8Array 또는 string)<br/>`connectionSeed`: 연결 시드 (Uint8Array 또는 string)<br/>`rowJson`: JSON 데이터 (string) |
|-------------|--------------------------|
| **반환값** | 트랜잭션 서명 (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.writeConnectionRow(
  connection, signer, 'my-db', connectionSeed,
  JSON.stringify({ message_id: '123', message: '안녕 친구야!', timestamp: Date.now() })
);
```

---

#### `fetchUserConnections()`

사용자의 UserState PDA 트랜잭션 히스토리를 분석하여 모든 연결(친구 요청)을 조회합니다. 각 연결에는 해당 앱을 식별하는 `dbRootId`가 포함됩니다.

| **파라미터** | `userPubkey`: 사용자 공개키 (string 또는 PublicKey)<br/>`options`: 선택적 설정 |
|-------------|--------------------------|
| **옵션** | `limit`: 조회할 최대 트랜잭션 수<br/>`before`: 페이지네이션용 서명<br/>`speed`: 속도 제한 프로필 ('light' \| 'medium' \| 'heavy' \| 'extreme') |
| **반환값** | `{ dbRootId, connectionPda, partyA, partyB, status, requester, blocker, timestamp }` 객체 배열 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const connections = await iqlabs.reader.fetchUserConnections(myPubkey, {
  speed: 'light',
  limit: 100
});

// 상태별 필터링
const pendingRequests = connections.filter(c => c.status === 'pending');
const friends = connections.filter(c => c.status === 'approved');
const blocked = connections.filter(c => c.status === 'blocked');

// 연결 상세 확인
connections.forEach(conn => {
  console.log(`${conn.partyA} <-> ${conn.partyB}, 상태: ${conn.status}`);
});
```

---

### 테이블 관리

#### `writeRow()`

| **파라미터** | `connection`: Solana RPC 연결<br/>`signer`: 서명 지갑<br/>`dbRootId`: 데이터베이스 ID (Uint8Array 또는 string)<br/>`tableSeed`: 테이블 이름 (Uint8Array 또는 string)<br/>`rowJson`: JSON 행 데이터 (string)<br/>`skipConfirmation`: 트랜잭션 확인 생략 (boolean, 기본값: false) |
|-------------|--------------------------|
| **반환값** | 트랜잭션 서명 (string) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 첫 번째 행을 작성하여 테이블 생성
await iqlabs.writer.writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 1, name: 'Alice', email: 'alice@example.com'
}));

// 같은 테이블에 다른 행 추가
await iqlabs.writer.writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 2, name: 'Bob', email: 'bob@example.com'
}));
```

---

#### `readTableRows()`

| **파라미터** | `account`: 테이블 PDA (PublicKey 또는 string)<br/>`options`: 선택적 설정 |
|-------------|--------------------------|
| **옵션** | `limit`: 가져올 최대 행 수<br/>`before`: 페이지네이션용 시그니처 커서<br/>`signatures`: 미리 수집한 시그니처 배열 (제공 시 RPC 조회 생략)<br/>`speed`: 속도 제한 프로필 ('light', 'medium', 'heavy', 'extreme') |
| **반환값** | `Array<Record<string, unknown>>` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 기본 사용
const rows = await iqlabs.reader.readTableRows(tablePda, { limit: 50 });

// 커서 기반 페이지네이션
const olderRows = await iqlabs.reader.readTableRows(tablePda, { limit: 50, before: 'sig...' });

// 미리 수집한 시그니처로 사용 (시그니처 조회 생략, 바로 디코딩)
const sigs = await iqlabs.reader.collectSignatures(tablePda);
const targetIdx = sigs.indexOf('abc123');
const slice = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: slice });
```

---

#### `collectSignatures()`

계정의 모든 (또는 `maxSignatures`개까지의) 트랜잭션 시그니처를 수집합니다. 가볍게 동작 — 트랜잭션 디코딩 없이 시그니처 문자열만 수집. 페이지네이션에 유용: 전체 시그니처 목록을 한 번 가져온 후 슬라이스하여 `readTableRows()`에 전달.

| **파라미터** | `account`: 테이블 PDA (PublicKey 또는 string)<br/>`maxSignatures`: 수집할 최대 시그니처 수 (선택, 생략 시 전체 수집) |
|-------------|--------------------------|
| **반환값** | `string[]` (시그니처 문자열) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 모든 시그니처 수집
const allSigs = await iqlabs.reader.collectSignatures(tablePda);

// 최대 3000개 시그니처 수집
const sigs = await iqlabs.reader.collectSignatures(tablePda, 3000);

// readTableRows와 함께 중간부터 읽기
const targetIdx = sigs.indexOf('abc123');
const chunk = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: chunk });
```

---

#### `getTablelistFromRoot()`

| **파라미터** | `connection`: Solana RPC 연결<br/>`dbRootId`: 데이터베이스 ID (Uint8Array 또는 string) |
|-------------|--------------------------|
| **반환값** | `{ rootPda: PublicKey, creator: string \| null, tableSeeds: string[], globalTableSeeds: string[] }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.getTablelistFromRoot(connection, 'my-db');
console.log('생성자:', result.creator);
console.log('테이블 시드:', result.tableSeeds);
```

---

#### `fetchInventoryTransactions()`

| **파라미터** | `publicKey`: 사용자 공개키 (PublicKey)<br/>`limit`: 최대 개수 (number)<br/>`before`: 페이지네이션 커서 (선택, string) |
|-------------|--------------------------|
| **반환값** | 트랜잭션 배열 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const myFiles = await iqlabs.reader.fetchInventoryTransactions(myPubkey, 20);
myFiles.forEach(tx => {
  let metadata: { data?: unknown } | null = null;
  try {
    metadata = JSON.parse(tx.metadata);
  } catch {
    metadata = null;
  }

  if (metadata && metadata.data !== undefined) {
    const inlineData = typeof metadata.data === 'string'
      ? metadata.data
      : JSON.stringify(metadata.data);
    console.log(`인라인 데이터: ${inlineData}`);
  } else {
    console.log(`서명: ${tx.signature}`);
  }
});
```

---

### 환경 설정

#### `setRpcUrl()`

| **파라미터** | `url`: Solana RPC URL (string) |
|-------------|--------------------------|
| **반환값** | 없음 (void) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

iqlabs.utils.setRpcUrl('https://your-rpc.example.com');
```

---

## 고급 함수

<Warning>
이 함수들은 SDK의 저수준 함수입니다. 일반적인 사용에는 필요하지 않지만, 커스텀 기능을 직접 구현하거나 디버깅할 때 유용합니다.
</Warning>

### Writer 함수

#### `manageRowData()`

테이블 행 쓰기와 연결 행 쓰기를 모두 처리하는 통합 함수입니다. 기존 PDA를 기반으로 테이블에 쓸지 연결에 쓸지 자동으로 감지합니다.

| **모듈** | `writer` |
|----------|----------|
| **파라미터** | `connection`: Solana RPC 연결<br/>`signer`: 서명 지갑<br/>`dbRootId`: 데이터베이스 ID (Uint8Array 또는 string)<br/>`seed`: 테이블 또는 연결 시드 (Uint8Array 또는 string)<br/>`rowJson`: JSON 행 데이터 (string)<br/>`tableName`: 테이블 수정 시 필요 (선택, string 또는 Uint8Array)<br/>`targetTx`: 테이블 수정 시 참조 트랜잭션 (선택, string 또는 Uint8Array) |
| **반환값** | 트랜잭션 서명 (string) |
| **사용 사례** | 커스텀 행 관리, 기존 행 업데이트 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.manageRowData(
  connection, signer,
  'my-db',       // dbRootId
  'users',       // seed (테이블 시드)
  JSON.stringify({ id: 1, name: '업데이트된 이름' }),
  'users',       // tableName
  originalTxSig  // targetTx
);
```

---

### Reader 함수

#### `readUserState()`

주어진 사용자의 UserState PDA를 읽습니다.

| **모듈** | `reader` |
|----------|----------|
| **파라미터** | `userPubkey`: 사용자 공개키 (string) |
| **반환값** | `{ owner: string, metadata: string \| null, totalSessionFiles: bigint, profileData?: string }` |
| **사용 사례** | 사용자 프로필 데이터 조회, 업로드 수 확인 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const userState = await iqlabs.reader.readUserState(userPubkey);
console.log('소유자:', userState.owner);
console.log('세션 파일:', userState.totalSessionFiles);
console.log('프로필 데이터:', userState.profileData);
```

---

#### `readInventoryMetadata()`

사용자의 인벤토리 트랜잭션과 관련된 메타데이터를 읽습니다.

| **모듈** | `reader` |
|----------|----------|
| **파라미터** | `txSignature`: 트랜잭션 서명 (string) |
| **반환값** | `{ onChainPath: string, metadata: string }` |
| **사용 사례** | 인벤토리 트랜잭션에서 파일 메타데이터 추출 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.readInventoryMetadata(txSignature);
console.log('경로:', result.onChainPath);
console.log('메타데이터:', result.metadata);
```

---

#### `getSessionPdaList()`

사용자의 세션 PDA 주소 목록을 조회합니다.

| **모듈** | `reader` |
|----------|----------|
| **파라미터** | `userPubkey`: 사용자 공개키 (string) |
| **반환값** | `string[]` (세션 PDA base58 문자열) |
| **사용 사례** | 세션 관리, 활성 세션 추적 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const sessions = await iqlabs.reader.getSessionPdaList(userPubkey);
sessions.forEach(pda => {
  console.log(`세션 PDA: ${pda}`);
});
```

---

### 유틸리티 함수

#### `deriveDmSeed()`

두 사용자 간의 다이렉트 메시지(DM)를 위한 결정적 시드를 생성합니다. 두 공개키를 알파벳순으로 정렬한 후 keccak256으로 해싱합니다.

| **모듈** | `utils` |
|----------|----------|
| **파라미터** | `userA`: 첫 번째 사용자 공개키 (string)<br/>`userB`: 두 번째 사용자 공개키 (string) |
| **반환값** | `Uint8Array` (시드 바이트) |
| **사용 사례** | 일관된 연결 식별자 생성, DM 채널 설정 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const seed1 = iqlabs.utils.deriveDmSeed(walletA, walletB);
const seed2 = iqlabs.utils.deriveDmSeed(walletB, walletA);
// seed1과 seed2는 동일합니다 — 순서는 상관없습니다
```

---

#### `toSeedBytes()`

시드 식별자를 바이트로 변환합니다. 입력이 64자 16진수 문자열이면 16진수 바이트를 직접 반환합니다. 그렇지 않으면 keccak256 해시를 적용합니다.

| **모듈** | `utils` |
|----------|----------|
| **파라미터** | `value`: 시드 문자열 또는 Uint8Array |
| **반환값** | `Uint8Array` |
| **사용 사례** | 커스텀 PDA 도출, 저수준 시드 조작 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const seedString = 'my-custom-seed';
const seedBytes = iqlabs.utils.toSeedBytes(seedString);

const [pda, bump] = PublicKey.findProgramAddressSync(
  [seedBytes, otherSeed],
  programId
);
```
