---
title: "개발자 문서 (Python)"
description: "IQLabs Python SDK의 핵심 개념과 함수"
---

<Note>
이 문서는 작성 중이며 계속 업데이트될 예정입니다.
</Note>

## 설치

```bash
pip install iqlabs-solana-sdk
```

---

## 핵심 개념

IQLabs SDK를 사용하기 전에 알아야 할 주요 개념들입니다.

---

### 데이터 저장 (Code In)

파일, 텍스트, JSON 등 모든 데이터를 온체인에 저장하는 방법입니다.

#### 어떻게 저장되나요?

데이터 크기에 따라 SDK가 최적의 방법을 자동으로 선택합니다:

- **작은 데이터 (&lt; 850 bytes)**: 즉시 저장, 가장 빠름
- **중간 데이터 (&lt; 8.5 KB)**: 여러 트랜잭션으로 분할
- **큰 데이터 (&gt;= 8.5 KB)**: 속도를 위해 병렬 업로드

#### 관련 주요 함수

- [`code_in()`](#code_in): 데이터를 업로드하고 트랜잭션 ID를 받음
- [`read_code_in()`](#read_code_in): 트랜잭션 ID로 데이터를 다시 읽음

---

### User State PDA

사용자를 위한 온체인 프로필 계정입니다.

#### 무엇이 저장되나요?

- 프로필 정보 (이름, 프로필 사진, 소개 등)
- 업로드한 파일 수
- 친구 요청 기록

<Note>
친구 요청은 PDA에 값으로 저장되지 않고 트랜잭션으로 전송됩니다.
</Note>

#### 언제 생성되나요?

[`code_in()`](#code_in)을 처음 호출할 때 자동으로 생성됩니다. 추가 설정이 필요 없지만, 처음 사용자는 두 번 서명해야 할 수 있습니다.

---

### Connection PDA

두 사용자 간의 관계(친구, 메시지 등)를 관리하는 온체인 계정입니다.

#### 어떤 상태가 있나요?

- **pending**: 친구 요청이 전송되었지만 아직 수락되지 않음
- **approved**: 요청이 수락되고 사용자들이 연결됨
- **blocked**: 한쪽이 다른 쪽을 차단함

<Warning>
차단된 연결은 차단한 사람만 해제할 수 있습니다.
</Warning>

#### 관련 주요 함수

- [`request_connection()`](#request_connection): 친구 요청 보내기 (pending 생성)
- [`manage_connection()`](#manage_connection): 요청 승인/거절/차단/해제
- [`read_connection()`](#read_connection): 현재 관계 상태 확인
- [`write_connection_row()`](#write_connection_row): 연결된 친구와 메시지/데이터 교환
- [`fetch_user_connections()`](#fetch_user_connections): 모든 연결 조회 (보낸/받은 친구 요청)

---

### 데이터베이스 테이블

데이터베이스처럼 테이블에 JSON 데이터를 저장합니다.

#### 테이블은 어떻게 생성되나요?

전용 "테이블 생성" 함수가 없습니다. [`write_row()`](#write_row)를 통한 첫 번째 쓰기가 자동으로 테이블을 생성합니다.

<Note>
테이블은 `db_root_id`와 `table_seed` (테이블 이름)의 조합으로 고유하게 식별됩니다.
</Note>

#### 관련 주요 함수

- [`write_row()`](#write_row): 새 행 추가 (테이블이 없으면 생성)
- [`read_table_rows()`](#read_table_rows): 테이블에서 행 읽기
- [`get_tablelist_from_root()`](#get_tablelist_from_root): 데이터베이스의 모든 테이블 목록 조회
- [`fetch_inventory_transactions()`](#fetch_inventory_transactions): 업로드한 파일 목록 조회

---

## 함수 상세

### 데이터 저장 및 조회

#### `code_in()`

| **파라미터** | `connection`: Solana RPC AsyncClient<br/>`signer`: Keypair 또는 WalletSigner<br/>`chunks`: 업로드할 데이터 (list[str])<br/>`filename`: 파일 이름 (선택, str 또는 None)<br/>`method`: 업로드 방식 (int, 기본값: 0)<br/>`filetype`: 파일 유형 힌트 (str, 기본값: '')<br/>`on_progress`: 진행률 콜백 (선택, Callable[[int], None]) |
|----------------|--------------------------|
| **반환값** | 트랜잭션 서명 (str) |

```python
from iqlabs import writer
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair

# 데이터 업로드
signature = await writer.code_in(connection, signer, ['Hello, blockchain!'])

# 파일 이름과 함께 업로드
signature = await writer.code_in(connection, signer, ['file contents here'], filename='hello.txt')
```

---

#### `read_code_in()`

| **파라미터** | `tx_signature`: 트랜잭션 서명 (str)<br/>`speed`: 속도 제한 프로필 (선택, str)<br/>`on_progress`: 진행률 콜백 (선택, Callable[[int], None]) |
|----------------|--------------------------|
| **반환값** | `metadata` (str)와 `data` (str 또는 None)를 포함하는 dict |

```python
from iqlabs import reader

result = await reader.read_code_in('5Xg7...')
print(result['data'])      # 'Hello, blockchain!'
print(result['metadata'])  # 파일 메타데이터가 포함된 JSON 문자열
```

---

### 연결 관리

#### `request_connection()`

| **파라미터** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: 데이터베이스 ID (bytes 또는 str)<br/>`party_a`: 첫 번째 사용자 공개키 (str)<br/>`party_b`: 두 번째 사용자 공개키 (str)<br/>`table_name`: 연결 테이블 이름 (str 또는 bytes)<br/>`columns`: 컬럼 목록 (list[str 또는 bytes])<br/>`id_col`: ID 컬럼 (str 또는 bytes)<br/>`ext_keys`: 확장 키 (list[str 또는 bytes]) |
|----------------|--------------------------|
| **반환값** | 트랜잭션 서명 (str) |

```python
from iqlabs import writer

await writer.request_connection(
    connection, signer, 'my-db',
    my_wallet_address, friend_wallet_address,
    'dm_table', ['message', 'timestamp'], 'message_id', []
)
```

---

#### `manage_connection()`

<Note>
이 함수에 대한 고수준 SDK 래퍼가 없습니다. 컨트랙트 수준의 인스트럭션 빌더를 직접 사용하세요.
</Note>

| **파라미터** | `builder`: InstructionBuilder<br/>`accounts`: `db_root`, `connection_table`, `signer`를 포함하는 dict<br/>`args`: `db_root_id`, `connection_seed`, `new_status`를 포함하는 dict |
|----------------|--------------------------|
| **반환값** | Instruction |

```python
from iqlabs import contract

# 인스트럭션 빌더 생성
builder = contract.create_instruction_builder(contract.get_program_id())

# 친구 요청 승인
approve_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_APPROVED}
)

# 사용자 차단
block_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_BLOCKED}
)
```

---

#### `read_connection()`

| **파라미터** | `db_root_id`: 데이터베이스 ID (bytes 또는 str)<br/>`party_a`: 첫 번째 지갑 (str)<br/>`party_b`: 두 번째 지갑 (str) |
|----------------|--------------------------|
| **반환값** | `status`, `requester`, `blocker`를 포함하는 dict |

```python
from iqlabs import reader

conn_info = await reader.read_connection('my-db', party_a, party_b)
print(conn_info['status'])  # 'pending' | 'approved' | 'blocked'
```

---

#### `write_connection_row()`

| **파라미터** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: 데이터베이스 ID (bytes 또는 str)<br/>`connection_seed`: 연결 시드 (bytes 또는 str)<br/>`row_json`: JSON 데이터 (str) |
|----------------|--------------------------|
| **반환값** | 트랜잭션 서명 (str) |

```python
from iqlabs import writer
import json

await writer.write_connection_row(
    connection, signer, 'my-db', connection_seed,
    json.dumps({"message_id": "123", "message": "Hello friend!", "timestamp": 1234567890})
)
```

---

#### `fetch_user_connections()`

사용자의 UserState PDA 트랜잭션 히스토리를 분석하여 모든 연결(친구 요청)을 조회합니다. 각 연결에는 해당 앱을 식별하는 `db_root_id`가 포함됩니다.

| **파라미터** | `user_pubkey`: 사용자 공개키 (str 또는 Pubkey)<br/>`limit`: 조회할 최대 트랜잭션 수 (선택)<br/>`before`: 페이지네이션용 서명 (선택)<br/>`speed`: 속도 제한 프로필 (선택) |
|----------------|--------------------------|
| **반환값** | db_root_id, connection_pda, party_a, party_b, status, requester, blocker, timestamp를 포함하는 연결 dict 목록 |

```python
from iqlabs import reader

# 모든 연결 조회 (모든 앱에 걸쳐!)
connections = await reader.fetch_user_connections(
    my_pubkey,
    speed="light",
    limit=100
)

# 상태별 필터링
pending_requests = [c for c in connections if c['status'] == 'pending']
friends = [c for c in connections if c['status'] == 'approved']
blocked = [c for c in connections if c['status'] == 'blocked']

# 연결 상세 확인
for conn in connections:
    print(f"Party A: {conn['party_a']} <-> Party B: {conn['party_b']}, status: {conn['status']}")
```

---

### 테이블 관리

#### `write_row()`

| **파라미터** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: 데이터베이스 ID (bytes 또는 str)<br/>`table_seed`: 테이블 이름 (bytes 또는 str)<br/>`row_json`: JSON 행 데이터 (str)<br/>`skip_confirmation`: 트랜잭션 확인 생략 (기본값: False) |
|----------------|--------------------------|
| **반환값** | 트랜잭션 서명 (str) |

```python
from iqlabs import writer
import json

# 첫 번째 행을 작성하여 테이블 생성
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 1, "name": "Alice", "email": "alice@example.com"
}))

# 같은 테이블에 다른 행 추가
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 2, "name": "Bob", "email": "bob@example.com"
}))
```

---

#### `read_table_rows()`

| **파라미터** | `account`: 테이블 PDA (Pubkey 또는 str)<br/>`before`: 페이지네이션용 시그니처 커서 (선택)<br/>`limit`: 가져올 최대 행 수 (선택)<br/>`speed`: 속도 제한 프로필 (선택) |
|----------------|--------------------------|
| **반환값** | `list[dict]` |

```python
from iqlabs import reader

# 기본 사용
rows = await reader.read_table_rows(table_pda, limit=50)

# 커서 기반 페이지네이션
older_rows = await reader.read_table_rows(table_pda, limit=50, before="sig...")
```

---

#### `get_tablelist_from_root()`

| **파라미터** | `connection`: AsyncClient<br/>`db_root_id`: 데이터베이스 ID (bytes 또는 str) |
|----------------|--------------------------|
| **반환값** | `root_pda`, `creator`, `table_seeds`, `global_table_seeds`를 포함하는 dict |

```python
from iqlabs import reader

result = await reader.get_tablelist_from_root(connection, 'my-db')
print('Creator:', result['creator'])
print('Table seeds:', result['table_seeds'])
```

---

#### `fetch_inventory_transactions()`

| **파라미터** | `public_key`: 사용자 공개키 (Pubkey)<br/>`limit`: 최대 개수 (int)<br/>`before`: 페이지네이션 커서 (선택, str) |
|----------------|--------------------------|
| **반환값** | 트랜잭션 목록 |

```python
from iqlabs import reader
from solders.pubkey import Pubkey
import json

my_files = await reader.fetch_inventory_transactions(my_pubkey, 20)
for tx in my_files:
    metadata = None
    try:
        metadata = json.loads(tx['metadata'])
    except:
        metadata = None

    if metadata and 'data' in metadata:
        inline_data = metadata['data'] if isinstance(metadata['data'], str) else json.dumps(metadata['data'])
        print(f"Inline data: {inline_data}")
    else:
        print(f"Signature: {tx['signature']}")
```

---

### 환경 설정

#### `set_rpc_url()`

| **파라미터** | `url`: Solana RPC URL (str) |
|----------------|--------------------------|
| **반환값** | None |

```python
from iqlabs import set_rpc_url

set_rpc_url('https://your-rpc.example.com')
```

---

## 고급 함수

<Warning>
이 함수들은 SDK의 저수준 함수입니다. 일반적인 사용에는 필요하지 않지만, 커스텀 기능을 직접 구현하거나 디버깅할 때 유용합니다.
</Warning>

### Writer 함수

#### `manage_row_data()`

테이블 행 쓰기와 연결 행 쓰기를 모두 처리하는 통합 함수입니다. 기존 PDA를 기반으로 테이블에 쓸지 연결에 쓸지 자동으로 감지합니다.

| **모듈** | `writer` |
|----------|----------|
| **파라미터** | `connection`: AsyncClient<br/>`signer`: Keypair<br/>`db_root_id`: 데이터베이스 ID (bytes 또는 str)<br/>`seed`: 테이블 또는 연결 시드 (bytes 또는 str)<br/>`row_json`: JSON 행 데이터 (str)<br/>`table_name`: 테이블 수정 시 필요 (선택)<br/>`target_tx`: 테이블 수정 시 참조 트랜잭션 (선택) |
| **반환값** | 트랜잭션 서명 (str) |
| **사용 사례** | 커스텀 행 관리, 기존 행 업데이트 |

```python
from iqlabs import writer
import json

await writer.manage_row_data(
    connection, signer,
    'my-db',       # db_root_id
    'users',       # seed (테이블 시드)
    json.dumps({"id": 1, "name": "Updated Name"}),
    table_name='users',
    target_tx=original_tx_sig
)
```

---

### Reader 함수

#### `read_user_state()`

주어진 사용자의 UserState PDA를 읽습니다.

| **모듈** | `reader` |
|----------|----------|
| **파라미터** | `user_pubkey`: 사용자 공개키 (str) |
| **반환값** | `owner`, `metadata`, `total_session_files`, `profile_data`를 포함하는 dict |
| **사용 사례** | 사용자 프로필 데이터 조회, 업로드 수 확인 |

```python
from iqlabs import reader

user_state = await reader.read_user_state(user_pubkey)
print('Owner:', user_state['owner'])
print('Session files:', user_state['total_session_files'])
print('Profile data:', user_state['profile_data'])
```

---

#### `read_inventory_metadata()`

사용자의 인벤토리 트랜잭션과 관련된 메타데이터를 읽습니다.

| **모듈** | `reader` |
|----------|----------|
| **파라미터** | `tx_signature`: 트랜잭션 서명 (str) |
| **반환값** | 메타데이터를 포함하는 dict |
| **사용 사례** | 인벤토리 트랜잭션에서 파일 메타데이터 추출 |

```python
from iqlabs import reader

result = await reader.read_inventory_metadata(tx_signature)
print('Metadata:', result)
```

---

#### `get_session_pda_list()`

사용자의 세션 PDA 주소 목록을 조회합니다.

| **모듈** | `reader` |
|----------|----------|
| **파라미터** | `user_pubkey`: 사용자 공개키 (str) |
| **반환값** | `list[str]` (세션 PDA base58 문자열) |
| **사용 사례** | 세션 관리, 활성 세션 추적 |

```python
from iqlabs import reader

sessions = await reader.get_session_pda_list(user_pubkey)
for pda in sessions:
    print(f"Session PDA: {pda}")
```

---

#### 컨트랙트 PDA 함수

`contract` 모듈에서 사용할 수 있는 저수준 PDA 도출 함수입니다.

| **모듈** | `contract` |
|----------|----------|
| **사용 사례** | 커스텀 PDA 도출, 계정 조회 |

```python
from iqlabs import contract
from solders.pubkey import Pubkey

program_id = contract.get_program_id()
db_root_pda = contract.get_db_root_pda(db_root_id, program_id)
table_pda = contract.get_table_pda(db_root_pda, table_seed, program_id)
user_pda = contract.get_user_pda(user_pubkey, program_id)
session_pda = contract.get_session_pda(user_pubkey, seq=0, program_id=program_id)
connection_pda = contract.get_connection_table_pda(db_root_pda, connection_seed, program_id)
```

---

### 유틸리티 함수

#### `derive_dm_seed()`

두 사용자 간의 다이렉트 메시지(DM)를 위한 결정적 시드를 생성합니다. 두 공개키를 알파벳순으로 정렬한 후 `"lower:upper"`를 Keccak-256으로 해싱합니다.

| **모듈** | `utils` |
|----------|----------|
| **파라미터** | `user_a`: 첫 번째 사용자 공개키 (str)<br/>`user_b`: 두 번째 사용자 공개키 (str) |
| **반환값** | bytes (32바이트 시드) |
| **사용 사례** | 일관된 연결 식별자 생성, DM 채널 설정 |

```python
from iqlabs.sdk.utils.seed import derive_dm_seed

seed1 = derive_dm_seed(wallet_a, wallet_b)
seed2 = derive_dm_seed(wallet_b, wallet_a)
print(seed1 == seed2)  # True — 순서는 상관없습니다
```

---

#### `to_seed_bytes()`

시드 식별자를 바이트로 변환합니다. 입력이 64자 16진수 문자열이면 그대로 통과합니다. 그렇지 않으면 Keccak-256 해시를 적용합니다.

| **모듈** | `utils` |
|----------|----------|
| **파라미터** | `value`: 시드 문자열 또는 bytes |
| **반환값** | bytes |
| **사용 사례** | 커스텀 PDA 도출, 저수준 시드 조작 |

```python
from iqlabs.sdk.utils.seed import to_seed_bytes
from solders.pubkey import Pubkey

seed_string = 'my-custom-seed'
seed_bytes = to_seed_bytes(seed_string)

pda, bump = Pubkey.find_program_address(
    [seed_bytes, other_seed],
    program_id
)
```

---
