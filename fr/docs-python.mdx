---
title: "Documentation développeur (Python)"
description: "Concepts et fonctions principaux du SDK Python IQLabs"
---

<Note>
Ce document est en cours de rédaction et sera affiné.
</Note>

## Installation

```bash
pip install iqlabs-solana-sdk
```

---

## Concepts fondamentaux

Voici les concepts clés à connaître avant d'utiliser le SDK IQLabs.

---

### Stockage de données (Code In)

Voici comment stocker n'importe quelles données (fichiers, texte, JSON) on-chain.

#### Comment sont-elles stockées ?

Selon la taille des données, le SDK choisit la méthode optimale :

- **Petites données (&lt; 850 octets)** : stockage immédiat, le plus rapide
- **Données moyennes (&lt; 8,5 Ko)** : réparties en plusieurs transactions
- **Grandes données (&gt;= 8,5 Ko)** : téléversement en parallèle pour plus de rapidité

#### Fonctions associées

- [`code_in()`](#code_in) : téléverser des données et obtenir un identifiant de transaction
- [`read_code_in()`](#read_code_in) : relire des données à partir d'un identifiant de transaction

---

### PDA d'état utilisateur

Un compte de profil on-chain pour un utilisateur.

#### Quelles données sont stockées ?

- Informations de profil (nom, photo de profil, bio, etc.)
- Nombre de fichiers téléversés
- Enregistrements de demandes d'ami

<Note>
Les demandes d'ami ne sont pas stockées en tant que valeurs dans le PDA ; elles sont envoyées sous forme de transactions.
</Note>

#### Quand est-il créé ?

Il est créé automatiquement la première fois que vous appelez [`code_in()`](#code_in). Aucune configuration supplémentaire n'est requise, mais le premier utilisateur peut avoir besoin de signer deux fois.

---

### PDA de connexion

Un compte on-chain qui gère les relations entre deux utilisateurs (amis, messages, etc.).

#### Quels états peut-il avoir ?

- **pending** (en attente) : une demande d'ami a été envoyée mais pas encore acceptée
- **approved** (approuvé) : la demande a été acceptée et les utilisateurs sont connectés
- **blocked** (bloqué) : l'un des deux a bloqué l'autre

<Warning>
Une connexion bloquée ne peut être débloquée que par la personne qui a effectué le blocage.
</Warning>

#### Fonctions associées

- [`request_connection()`](#request_connection) : envoyer une demande d'ami (crée un état en attente)
- [`manage_connection()`](#manage_connection) : approuver/rejeter/bloquer/débloquer une demande
- [`read_connection()`](#read_connection) : vérifier l'état actuel de la relation
- [`write_connection_row()`](#write_connection_row) : échanger des messages/données avec un ami connecté
- [`fetch_user_connections()`](#fetch_user_connections) : récupérer toutes les connexions (demandes d'ami envoyées et reçues)

---

### Tables de base de données

Stocker des données JSON dans des tables comme dans une base de données.

#### Comment les tables sont-elles créées ?

Il n'existe pas de fonction dédiée « créer une table ». La première écriture via [`write_row()`](#write_row) crée la table automatiquement.

<Note>
Une table est identifiée de manière unique par la combinaison de `db_root_id` et `table_seed` (nom de la table).
</Note>

#### Fonctions associées

- [`write_row()`](#write_row) : ajouter une nouvelle ligne (crée la table si elle n'existe pas)
- [`read_table_rows()`](#read_table_rows) : lire les lignes d'une table
- [`get_tablelist_from_root()`](#get_tablelist_from_root) : lister toutes les tables d'une base de données
- [`fetch_inventory_transactions()`](#fetch_inventory_transactions) : lister les fichiers téléversés

---

## Détails des fonctions

### Stockage et récupération de données

#### `code_in()`

| **Paramètres** | `connection` : AsyncClient Solana RPC<br/>`signer` : Keypair ou WalletSigner<br/>`chunks` : données à téléverser (list[str])<br/>`filename` : nom de fichier optionnel (str ou None)<br/>`method` : méthode de téléversement (int, par défaut : 0)<br/>`filetype` : indication du type de fichier (str, par défaut : '')<br/>`on_progress` : rappel de progression optionnel (Callable[[int], None]) |
|----------------|--------------------------|
| **Retourne** | Signature de transaction (str) |

```python
from iqlabs import writer
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair

# Téléverser des données
signature = await writer.code_in(connection, signer, ['Hello, blockchain!'])

# Téléverser avec un nom de fichier
signature = await writer.code_in(connection, signer, ['file contents here'], filename='hello.txt')
```

---

#### `read_code_in()`

| **Paramètres** | `tx_signature` : signature de transaction (str)<br/>`speed` : profil de limitation de débit (optionnel, str)<br/>`on_progress` : rappel de progression optionnel (Callable[[int], None]) |
|----------------|--------------------------|
| **Retourne** | dict avec `metadata` (str) et `data` (str ou None) |

```python
from iqlabs import reader

result = await reader.read_code_in('5Xg7...')
print(result['data'])      # 'Hello, blockchain!'
print(result['metadata'])  # Chaîne JSON avec les métadonnées du fichier
```

---

### Gestion des connexions

#### `request_connection()`

| **Paramètres** | `connection` : AsyncClient<br/>`signer` : Keypair<br/>`db_root_id` : identifiant de base de données (bytes ou str)<br/>`party_a` : clé publique du premier utilisateur (str)<br/>`party_b` : clé publique du second utilisateur (str)<br/>`table_name` : nom de la table de connexion (str ou bytes)<br/>`columns` : liste de colonnes (list[str ou bytes])<br/>`id_col` : colonne d'identifiant (str ou bytes)<br/>`ext_keys` : clés d'extension (list[str ou bytes]) |
|----------------|--------------------------|
| **Retourne** | Signature de transaction (str) |

```python
from iqlabs import writer

await writer.request_connection(
    connection, signer, 'my-db',
    my_wallet_address, friend_wallet_address,
    'dm_table', ['message', 'timestamp'], 'message_id', []
)
```

---

#### `manage_connection()`

<Note>
Il n'existe pas de wrapper SDK de haut niveau pour cette fonction. Utilisez directement le constructeur d'instructions au niveau du contrat.
</Note>

| **Paramètres** | `builder` : InstructionBuilder<br/>`accounts` : dict avec `db_root`, `connection_table`, `signer`<br/>`args` : dict avec `db_root_id`, `connection_seed`, `new_status` |
|----------------|--------------------------|
| **Retourne** | Instruction |

```python
from iqlabs import contract

# Créer un constructeur d'instructions
builder = contract.create_instruction_builder(contract.get_program_id())

# Approuver une demande d'ami
approve_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_APPROVED}
)

# Bloquer un utilisateur
block_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_BLOCKED}
)
```

---

#### `read_connection()`

| **Paramètres** | `db_root_id` : identifiant de base de données (bytes ou str)<br/>`party_a` : premier portefeuille (str)<br/>`party_b` : second portefeuille (str) |
|----------------|--------------------------|
| **Retourne** | dict avec `status`, `requester`, `blocker` |

```python
from iqlabs import reader

conn_info = await reader.read_connection('my-db', party_a, party_b)
print(conn_info['status'])  # 'pending' | 'approved' | 'blocked'
```

---

#### `write_connection_row()`

| **Paramètres** | `connection` : AsyncClient<br/>`signer` : Keypair<br/>`db_root_id` : identifiant de base de données (bytes ou str)<br/>`connection_seed` : graine de connexion (bytes ou str)<br/>`row_json` : données JSON (str) |
|----------------|--------------------------|
| **Retourne** | Signature de transaction (str) |

```python
from iqlabs import writer
import json

await writer.write_connection_row(
    connection, signer, 'my-db', connection_seed,
    json.dumps({"message_id": "123", "message": "Hello friend!", "timestamp": 1234567890})
)
```

---

#### `fetch_user_connections()`

Récupère toutes les connexions (demandes d'ami) d'un utilisateur en analysant l'historique des transactions de son PDA UserState. Chaque connexion inclut son `db_root_id`, identifiant l'application à laquelle la connexion appartient.

| **Paramètres** | `user_pubkey` : clé publique de l'utilisateur (str ou Pubkey)<br/>`limit` : nombre maximum de transactions à récupérer (optionnel)<br/>`before` : signature pour la pagination (optionnel)<br/>`speed` : profil de limitation de débit (optionnel) |
|----------------|--------------------------|
| **Retourne** | Liste de dicts de connexion avec db_root_id, connection_pda, party_a, party_b, status, requester, blocker, timestamp |

```python
from iqlabs import reader

# Récupérer toutes les connexions (à travers toutes les applications !)
connections = await reader.fetch_user_connections(
    my_pubkey,
    speed="light",
    limit=100
)

# Filtrer par statut
pending_requests = [c for c in connections if c['status'] == 'pending']
friends = [c for c in connections if c['status'] == 'approved']
blocked = [c for c in connections if c['status'] == 'blocked']

# Vérifier les détails d'une connexion
for conn in connections:
    print(f"Party A: {conn['party_a']} <-> Party B: {conn['party_b']}, status: {conn['status']}")
```

---

### Gestion des tables

#### `write_row()`

| **Paramètres** | `connection` : AsyncClient<br/>`signer` : Keypair<br/>`db_root_id` : identifiant de base de données (bytes ou str)<br/>`table_seed` : nom de la table (bytes ou str)<br/>`row_json` : données JSON de la ligne (str)<br/>`skip_confirmation` : ignorer la confirmation de la tx (par défaut : False) |
|----------------|--------------------------|
| **Retourne** | Signature de transaction (str) |

```python
from iqlabs import writer
import json

# Écrire la première ligne pour créer la table
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 1, "name": "Alice", "email": "alice@example.com"
}))

# Ajouter une autre ligne à la même table
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 2, "name": "Bob", "email": "bob@example.com"
}))
```

---

#### `read_table_rows()`

| **Paramètres** | `account` : PDA de la table (Pubkey ou str)<br/>`before` : curseur de signature pour la pagination (optionnel)<br/>`limit` : nombre maximum de lignes à récupérer (optionnel)<br/>`speed` : profil de limitation de débit (optionnel) |
|----------------|--------------------------|
| **Retourne** | `list[dict]` |

```python
from iqlabs import reader

# Utilisation basique
rows = await reader.read_table_rows(table_pda, limit=50)

# Pagination par curseur
older_rows = await reader.read_table_rows(table_pda, limit=50, before="sig...")
```

---

#### `get_tablelist_from_root()`

| **Paramètres** | `connection` : AsyncClient<br/>`db_root_id` : identifiant de base de données (bytes ou str) |
|----------------|--------------------------|
| **Retourne** | dict avec `root_pda`, `creator`, `table_seeds`, `global_table_seeds` |

```python
from iqlabs import reader

result = await reader.get_tablelist_from_root(connection, 'my-db')
print('Creator:', result['creator'])
print('Table seeds:', result['table_seeds'])
```

---

#### `fetch_inventory_transactions()`

| **Paramètres** | `public_key` : clé publique de l'utilisateur (Pubkey)<br/>`limit` : nombre maximum (int)<br/>`before` : curseur de pagination (optionnel, str) |
|----------------|--------------------------|
| **Retourne** | Liste de transactions |

```python
from iqlabs import reader
from solders.pubkey import Pubkey
import json

my_files = await reader.fetch_inventory_transactions(my_pubkey, 20)
for tx in my_files:
    metadata = None
    try:
        metadata = json.loads(tx['metadata'])
    except:
        metadata = None

    if metadata and 'data' in metadata:
        inline_data = metadata['data'] if isinstance(metadata['data'], str) else json.dumps(metadata['data'])
        print(f"Inline data: {inline_data}")
    else:
        print(f"Signature: {tx['signature']}")
```

---

### Paramètres d'environnement

#### `set_rpc_url()`

| **Paramètres** | `url` : URL RPC Solana (str) |
|----------------|--------------------------|
| **Retourne** | None |

```python
from iqlabs import set_rpc_url

set_rpc_url('https://your-rpc.example.com')
```

---

## Fonctions avancées

<Warning>
Ce sont des fonctions SDK de bas niveau. Elles ne sont pas nécessaires pour une utilisation courante, mais utiles pour développer des fonctionnalités personnalisées ou pour le débogage.
</Warning>

### Fonctions d'écriture

#### `manage_row_data()`

Fonction unifiée qui gère à la fois les écritures de lignes de table et les écritures de lignes de connexion. Détecte automatiquement s'il faut écrire dans une table ou une connexion en fonction des PDA existants.

| **Module** | `writer` |
|------------|----------|
| **Paramètres** | `connection` : AsyncClient<br/>`signer` : Keypair<br/>`db_root_id` : identifiant de base de données (bytes ou str)<br/>`seed` : graine de table ou de connexion (bytes ou str)<br/>`row_json` : données JSON de la ligne (str)<br/>`table_name` : requis pour les modifications de table (optionnel)<br/>`target_tx` : tx de référence pour les modifications de table (optionnel) |
| **Retourne** | Signature de transaction (str) |
| **Cas d'utilisation** | Gestion personnalisée des lignes, mise à jour de lignes existantes |

```python
from iqlabs import writer
import json

await writer.manage_row_data(
    connection, signer,
    'my-db',       # db_root_id
    'users',       # seed (graine de table)
    json.dumps({"id": 1, "name": "Updated Name"}),
    table_name='users',
    target_tx=original_tx_sig
)
```

---

### Fonctions de lecture

#### `read_user_state()`

Lit le PDA UserState d'un utilisateur donné.

| **Module** | `reader` |
|------------|----------|
| **Paramètres** | `user_pubkey` : clé publique de l'utilisateur (str) |
| **Retourne** | dict avec `owner`, `metadata`, `total_session_files`, `profile_data` |
| **Cas d'utilisation** | Récupération des données de profil utilisateur, vérification des compteurs de téléversement |

```python
from iqlabs import reader

user_state = await reader.read_user_state(user_pubkey)
print('Owner:', user_state['owner'])
print('Session files:', user_state['total_session_files'])
print('Profile data:', user_state['profile_data'])
```

---

#### `read_inventory_metadata()`

Lit les métadonnées associées à une transaction d'inventaire d'un utilisateur.

| **Module** | `reader` |
|------------|----------|
| **Paramètres** | `tx_signature` : signature de transaction (str) |
| **Retourne** | dict avec les métadonnées |
| **Cas d'utilisation** | Extraction des métadonnées de fichier à partir des transactions d'inventaire |

```python
from iqlabs import reader

result = await reader.read_inventory_metadata(tx_signature)
print('Metadata:', result)
```

---

#### `get_session_pda_list()`

Récupère une liste d'adresses PDA de session pour un utilisateur.

| **Module** | `reader` |
|------------|----------|
| **Paramètres** | `user_pubkey` : clé publique de l'utilisateur (str) |
| **Retourne** | `list[str]` (chaînes base58 des PDA de session) |
| **Cas d'utilisation** | Gestion de sessions, suivi des sessions actives |

```python
from iqlabs import reader

sessions = await reader.get_session_pda_list(user_pubkey)
for pda in sessions:
    print(f"Session PDA: {pda}")
```

---

#### Fonctions PDA du contrat

Fonctions de dérivation PDA de bas niveau disponibles dans le module `contract`.

| **Module** | `contract` |
|------------|----------|
| **Cas d'utilisation** | Dérivation PDA personnalisée, recherche de comptes |

```python
from iqlabs import contract
from solders.pubkey import Pubkey

program_id = contract.get_program_id()
db_root_pda = contract.get_db_root_pda(db_root_id, program_id)
table_pda = contract.get_table_pda(db_root_pda, table_seed, program_id)
user_pda = contract.get_user_pda(user_pubkey, program_id)
session_pda = contract.get_session_pda(user_pubkey, seq=0, program_id=program_id)
connection_pda = contract.get_connection_table_pda(db_root_pda, connection_seed, program_id)
```

---

### Fonctions utilitaires

#### `derive_dm_seed()`

Dérive une graine déterministe pour la messagerie directe (DM) entre deux utilisateurs. Trie les deux clés publiques par ordre alphabétique et hache `"inférieure:supérieure"` avec Keccak-256.

| **Module** | `utils` |
|------------|----------|
| **Paramètres** | `user_a` : clé publique du premier utilisateur (str)<br/>`user_b` : clé publique du second utilisateur (str) |
| **Retourne** | bytes (graine de 32 octets) |
| **Cas d'utilisation** | Création d'identifiants de connexion cohérents, configuration de canaux de messagerie directe |

```python
from iqlabs.sdk.utils.seed import derive_dm_seed

seed1 = derive_dm_seed(wallet_a, wallet_b)
seed2 = derive_dm_seed(wallet_b, wallet_a)
print(seed1 == seed2)  # True — l'ordre n'a pas d'importance
```

---

#### `to_seed_bytes()`

Convertit un identifiant de graine en bytes. Si l'entrée est une chaîne hexadécimale de 64 caractères, elle est transmise telle quelle. Sinon, un hachage Keccak-256 est appliqué.

| **Module** | `utils` |
|------------|----------|
| **Paramètres** | `value` : chaîne ou bytes de la graine |
| **Retourne** | bytes |
| **Cas d'utilisation** | Dérivation PDA personnalisée, manipulation de graines de bas niveau |

```python
from iqlabs.sdk.utils.seed import to_seed_bytes
from solders.pubkey import Pubkey

seed_string = 'my-custom-seed'
seed_bytes = to_seed_bytes(seed_string)

pda, bump = Pubkey.find_program_address(
    [seed_bytes, other_seed],
    program_id
)
```

---
