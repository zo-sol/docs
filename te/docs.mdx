---
title: "డెవలపర్ డాక్స్"
description: "IQLabs SDK కోసం ప్రధాన భావనలు మరియు ఫంక్షన్లు"
---

<Note>
ఈ డాక్యుమెంట్ ప్రగతిలో ఉంది; ఇంకా మెరుగుపరచబడుతుంది.
</Note>

## ఇన్‌స్టాలేషన్

```bash
npm i @iqlabs-official/solana-sdk
```

---

## ప్రధాన భావనలు

IQLabs SDK ను ఉపయోగించే ముందు తెలుసుకోవాల్సిన ప్రధాన భావనలు ఇవే.

---

### డేటా స్టోరేజ్ (Code In)

ఇది ఏదైనా డేటా (ఫైళ్లు, టెక్స్ట్, JSON) ను ఆన్-చెయిన్‌లో నిల్వ చేసే విధానం.

#### ఇది ఎలా నిల్వ అవుతుంది?

డేటా పరిమాణంపై ఆధారపడి, SDK ఉత్తమ విధానాన్ని ఎంచుకుంటుంది:

- **చిన్న డేటా (&lt; 900 bytes)**: వెంటనే నిల్వ, అత్యంత వేగంగా
- **మధ్య డేటా (&lt; 8.5 KB)**: అనేక ట్రాన్సాక్షన్‌లుగా విభజిస్తుంది
- **పెద్ద డేటా (&gt;= 8.5 KB)**: వేగం కోసం సమాంతరంగా అప్‌లోడ్ చేస్తుంది

#### సంబంధిత ప్రధాన ఫంక్షన్లు

- [`codeIn()`](#codein): డేటాను అప్‌లోడ్ చేసి ట్రాన్సాక్షన్ ID పొందండి
- [`readCodeIn()`](#readcodein): ట్రాన్సాక్షన్ ID తో డేటాను తిరిగి చదవండి

---

### యూజర్ స్టేట్ PDA

ఒక యూజర్‌కు సంబంధించిన ఆన్-చెయిన్ ప్రొఫైల్ అకౌంట్.

#### ఏవి నిల్వ అవుతాయి?

- ప్రొఫైల్ సమాచారం (పేరు, ప్రొఫైల్ ఫోటో, బయో మొదలైనవి)
- అప్‌లోడ్ చేసిన ఫైళ్ల సంఖ్య
- ఫ్రెండ్ రిక్వెస్ట్ రికార్డులు

<Note>
ఫ్రెండ్ రిక్వెస్ట్‌లు PDA లో విలువలుగా నిల్వ కావు; అవి ట్రాన్సాక్షన్‌లుగా పంపబడతాయి.
</Note>

#### ఇది ఎప్పుడు సృష్టించబడుతుంది?

మీరు మొదటిసారి [`codeIn()`](#codein) ను కాల్ చేసినప్పుడు ఇది ఆటోమేటిక్‌గా సృష్టించబడుతుంది. అదనపు సెటప్ అవసరం లేదు, అయితే మొదటి యూజర్‌కు రెండుసార్లు సైన్ చేయాల్సి రావచ్చు.

---

### కనెక్షన్ PDA

రెండు యూజర్ల మధ్య సంబంధాలను (ఫ్రెండ్స్, మెసేజెస్ మొదలైనవి) నిర్వహించే ఆన్-చెయిన్ అకౌంట్.

#### దీనికి ఏ స్థితులు ఉంటాయి?

- **pending**: ఫ్రెండ్ రిక్వెస్ట్ పంపబడింది కానీ ఇంకా అంగీకరించబడలేదు
- **approved**: రిక్వెస్ట్ అంగీకరించబడింది, యూజర్లు కనెక్ట్ అయ్యారు
- **blocked**: ఒక పక్షం మరో పక్షాన్ని బ్లాక్ చేసింది

<Warning>
బ్లాక్ చేసిన కనెక్షన్‌ను బ్లాక్ చేసిన వ్యక్తి మాత్రమే అన్‌బ్లాక్ చేయగలడు.
</Warning>

#### సంబంధిత ప్రధాన ఫంక్షన్లు

- [`requestConnection()`](#requestconnection): ఫ్రెండ్ రిక్వెస్ట్ పంపండి (pending ను సృష్టిస్తుంది)
- [`manageConnection()`](#manageconnection): రిక్వెస్ట్‌ను అంగీకరించండి/తిరస్కరించండి/బ్లాక్/అన్‌బ్లాక్ చేయండి
- [`readConnection()`](#readconnection): ప్రస్తుత సంబంధ స్థితిని తనిఖీ చేయండి
- [`writeConnectionRow()`](#writeconnectionrow): కనెక్ట్ అయిన ఫ్రెండ్‌తో సందేశాలు/డేటా మార్పిడి చేయండి
- [`fetchUserConnections()`](#fetchuserconnections): అన్ని కనెక్షన్లు పొందండి (పంపిన & స్వీకరించిన రిక్వెస్ట్‌లు)

---

### డేటాబేస్ టేబుళ్లు

JSON డేటాను డేటాబేస్‌లా టేబుళ్లలో నిల్వ చేయండి.

#### టేబుళ్లు ఎలా సృష్టించబడతాయి?

ప్రత్యేక "create table" ఫంక్షన్ లేదు. [`writeRow()`](#writerow) ద్వారా మొదటి రైటు టేబుల్‌ను ఆటోమేటిక్‌గా సృష్టిస్తుంది.

<Note>
ఒక టేబుల్ `dbRootId` మరియు `tableSeed` (టేబుల్ పేరు) కలయికతో ప్రత్యేకంగా గుర్తించబడుతుంది.
</Note>

#### సంబంధిత ప్రధాన ఫంక్షన్లు

- [`writeRow()`](#writerow): కొత్త రోను జోడించండి (లేకపోతే టేబుల్‌ను సృష్టిస్తుంది)
- [`readTableRows()`](#readtablerows): టేబుల్ రోలను చదవండి
- [`getTablelistFromRoot()`](#gettablelistfromroot): డేటాబేస్‌లోని అన్ని టేబుళ్లను జాబితా చేయండి
- [`fetchInventoryTransactions()`](#fetchinventorytransactions): అప్‌లోడ్ చేసిన ఫైళ్లను జాబితా చేయండి

---

## ఫంక్షన్ వివరాలు

### డేటా స్టోరేజ్ మరియు రిట్రీవల్

#### `codeIn()`

| **పారామీటర్లు** | `connection`: Solana RPC కనెక్షన్<br/>`signer`: సైనింగ్ వాలెట్<br/>`data`: అప్‌లోడ్ చేయాల్సిన డేటా (ఒకే స్ట్రింగ్ లేదా అర్రే)<br/>`mode`: కాంట్రాక్ట్ మోడ్ (డీఫాల్ట్: 'anchor') |
|----------------|--------------------------|
| **రిటర్న్** | ట్రాన్సాక్షన్ సిగ్నేచర్ (string) |

```typescript
import { codeIn } from '@iqlabs-official/solana-sdk';

// ఒకే ఫైల్‌ను అప్‌లోడ్ చేయండి
const signature = await codeIn(connection, signer, 'Hello, blockchain!');

// అనేక ఫైళ్లను అప్‌లోడ్ చేయండి
const multiSig = await codeIn(connection, signer, ['file1.txt', 'file2.txt', 'file3.txt']);
```

---

#### `readCodeIn()`

| **పారామీటర్లు** | `txSignature`: ట్రాన్సాక్షన్ సిగ్నేచర్<br/>`connection`: (ఐచ్చికం) Solana RPC కనెక్షన్ |
|----------------|--------------------------|
| **రిటర్న్** | నిల్వ చేసిన డేటా (string) |

```typescript
import { readCodeIn } from '@iqlabs-official/solana-sdk';

const data = await readCodeIn('5Xg7...', connection);
console.log(data); // 'Hello, blockchain!'
```

---

### కనెక్షన్ నిర్వహణ

#### `requestConnection()`

| **పారామీటర్లు** | `connection`: Solana RPC కనెక్షన్<br/>`signer`: సైనింగ్ వాలెట్<br/>`dbRootId`: డేటాబేస్ ID<br/>`partyA`, `partyB`: కనెక్ట్ చేయాల్సిన ఇద్దరు యూజర్లు<br/>`tableName`: కనెక్షన్ టేబుల్ పేరు<br/>`columns`: కాలమ్ లిస్ట్<br/>`idCol`: ID కాలమ్<br/>`extKeys`: ఎక్స్‌టెన్షన్ కీలు |
|----------------|--------------------------|
| **రిటర్న్** | ట్రాన్సాక్షన్ సిగ్నేచర్ (string) |

```typescript
import { requestConnection } from '@iqlabs-official/solana-sdk';

// ఫ్రెండ్ రిక్వెస్ట్ పంపండి
await requestConnection(
  connection, signer, 'my-db',
  myWalletAddress, friendWalletAddress,
  'dm_table', ['message', 'timestamp'], 'message_id', []
);
```

---

#### `manageConnection()`

| **పారామీటర్లు** | `builder`: InstructionBuilder<br/>`accounts`: `{ db_root, connection_table, signer }`<br/>`args`: `{ db_root_id, connection_seed, new_status }` |
|----------------|--------------------------|
| **రిటర్న్** | TransactionInstruction |

```typescript
import { contract } from '@iqlabs-official/solana-sdk';

// ఫ్రెండ్ రిక్వెస్ట్‌ను అంగీకరించండి
const approveIx = contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: contract.CONNECTION_STATUS_APPROVED }
);

// యూజర్‌ను బ్లాక్ చేయండి
const blockIx = contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: contract.CONNECTION_STATUS_BLOCKED }
);
```

---

#### `readConnection()`

| **పారామీటర్లు** | `dbRootId`: డేటాబేస్ ID<br/>`walletA`, `walletB`: పరిశీలించాల్సిన రెండు వాలెట్లు |
|----------------|--------------------------|
| **రిటర్న్** | `{ status: 'pending' \| 'approved' \| 'blocked', requester, blocker }` |

```typescript
import { readConnection } from '@iqlabs-official/solana-sdk';

const { status, requester, blocker } = await readConnection('my-db', walletA, walletB);
console.log(status); // 'pending' | 'approved' | 'blocked'
```

---

#### `writeConnectionRow()`

| **పారామీటర్లు** | `connection`: Solana RPC కనెక్షన్<br/>`signer`: సైనింగ్ వాలెట్<br/>`dbRootId`: డేటాబేస్ ID<br/>`connectionSeed`: కనెక్షన్ సీడ్<br/>`rowJson`: JSON డేటా |
|----------------|--------------------------|
| **రిటర్న్** | ట్రాన్సాక్షన్ సిగ్నేచర్ (string) |

```typescript
import { writeConnectionRow } from '@iqlabs-official/solana-sdk';

await writeConnectionRow(
  connection, signer, 'my-db', connectionSeed,
  JSON.stringify({ message_id: '123', message: 'Hello friend!', timestamp: Date.now() })
);
```

---

#### `fetchUserConnections()`

UserState PDA ట్రాన్సాక్షన్ హిస్టరీని విశ్లేషించి యూజర్ యొక్క అన్ని కనెక్షన్లు (ఫ్రెండ్ రిక్వెస్ట్‌లు)ను పొందుతుంది. ప్రతి కనెక్షన్‌లో అది ఏ యాప్‌కు చెందినదో సూచించే `dbRootId` ఉంటుంది.

| **పారామీటర్లు** | `userPubkey`: యూజర్ పబ్లిక్ కీ (string లేదా PublicKey)<br/>`options`: ఐచ్చిక సెట్టింగ్స్ |
|----------------|--------------------------|
| **ఆప్షన్లు** | `limit`: తీసుకోవాల్సిన గరిష్ఠ ట్రాన్సాక్షన్ల సంఖ్య<br/>`before`: పేజినేషన్ కోసం సిగ్నేచర్<br/>`speed`: రేట్ లిమిట్ ప్రొఫైల్ ('light', 'medium', 'heavy', 'extreme')<br/>`mode`: కాంట్రాక్ట్ మోడ్ (ఐచ్చికం) |
| **రిటర్న్** | dbRootId, partyA, partyB, status, requester, blocker, timestamp తో కూడిన కనెక్షన్ ఆబ్జెక్టుల అర్రే |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { fetchUserConnections } = iqlabs.reader;

// అన్ని కనెక్షన్లు పొందండి (అన్ని యాప్‌లు!)
const connections = await fetchUserConnections(myPubkey, {
  speed: 'light',  // 6 RPS (డీఫాల్ట్)
  limit: 100
});

// యాప్ ఆధారంగా ఫిల్టర్
const solchatConnections = connections.filter(c => c.dbRootId === 'solchat');
const zoConnections = connections.filter(c => c.dbRootId === 'zo-trading');

// స్థితి ఆధారంగా ఫిల్టర్
const pendingRequests = connections.filter(c => c.status === 'pending');
const friends = connections.filter(c => c.status === 'approved');
const blocked = connections.filter(c => c.status === 'blocked');

// కనెక్షన్ వివరాలు పరిశీలించండి
connections.forEach(conn => {
  console.log(`App: ${conn.dbRootId}, ${conn.partyA} <-> ${conn.partyB}, status: ${conn.status}`);
});
```

---

### టేబుల్ నిర్వహణ

#### `writeRow()`

| **పారామీటర్లు** | `connection`: Solana RPC కనెక్షన్<br/>`signer`: సైనింగ్ వాలెట్<br/>`dbRootId`: డేటాబేస్ ID<br/>`tableSeed`: టేబుల్ పేరు<br/>`rowJson`: JSON రో డేటా |
|----------------|--------------------------|
| **రిటర్న్** | ట్రాన్సాక్షన్ సిగ్నేచర్ (string) |

```typescript
import { writeRow } from '@iqlabs-official/solana-sdk';

// మొదటి రోను రాసి టేబుల్ సృష్టించండి
await writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 1, name: 'Alice', email: 'alice@example.com'
}));

// అదే టేబుల్‌లో మరో రో జోడించండి
await writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 2, name: 'Bob', email: 'bob@example.com'
}));
```

---

#### `readTableRows()`

| **Parameters** | `account`: table PDA (PublicKey or string)<br/>`options`: optional settings |
|----------------|--------------------------|
| **Options** | `limit`: max number of rows to fetch<br/>`before`: signature cursor for pagination<br/>`signatures`: pre-collected signature array (skips RPC fetch if provided)<br/>`speed`: rate limit profile ('light', 'medium', 'heavy', 'extreme') |
| **Returns** | `Array<Record<string, unknown>>` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Basic usage
const rows = await iqlabs.reader.readTableRows(tablePda, { limit: 50 });

// Cursor-based pagination
const olderRows = await iqlabs.reader.readTableRows(tablePda, { limit: 50, before: 'sig...' });

// With pre-collected signatures (skips signature fetching, decodes directly)
const sigs = await iqlabs.reader.collectSignatures(tablePda);
const targetIdx = sigs.indexOf('abc123');
const slice = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: slice });
```

---

#### `collectSignatures()`

Collects all (or up to `maxSignatures`) transaction signatures for an account. Lightweight — no transaction decoding, only signature strings. Useful for pagination: fetch the full signature list once, then slice and pass to `readTableRows()`.

| **Parameters** | `account`: table PDA (PublicKey or string)<br/>`maxSignatures`: max number of signatures to collect (optional, fetches all if omitted) |
|----------------|--------------------------|
| **Returns** | `string[]` (signature strings) |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// Collect all signatures
const allSigs = await iqlabs.reader.collectSignatures(tablePda);

// Collect up to 3000 signatures
const sigs = await iqlabs.reader.collectSignatures(tablePda, 3000);

// Use with readTableRows to read from the middle
const targetIdx = sigs.indexOf('abc123');
const chunk = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: chunk });
```

---

#### `getTablelistFromRoot()`

| **పారామీటర్లు** | `dbRootId`: డేటాబేస్ ID |
|----------------|--------------------------|
| **రిటర్న్** | టేబుల్ పేర్ల అర్రే (string[]) |

```typescript
import { getTablelistFromRoot } from '@iqlabs-official/solana-sdk';

const tables = await getTablelistFromRoot('my-db');
console.log('Table list:', tables);
```

---

#### `fetchInventoryTransactions()`

| **పారామీటర్లు** | `userPubkey`: యూజర్ పబ్లిక్ కీ<br/>`limit`: గరిష్ఠం (ఐచ్చికం) |
|----------------|--------------------------|
| **రిటర్న్** | ట్రాన్సాక్షన్ అర్రే |

```typescript
import { fetchInventoryTransactions } from '@iqlabs-official/solana-sdk';

const myFiles = await fetchInventoryTransactions(myPubkey, 20);
myFiles.forEach(tx => {
  let metadata: { data?: unknown } | null = null;
  try {
    metadata = JSON.parse(tx.metadata);
  } catch {
    metadata = null;
  }

  if (metadata && metadata.data !== undefined) {
    const inlineData = typeof metadata.data === 'string'
      ? metadata.data
      : JSON.stringify(metadata.data);
    console.log(`Inline data: ${inlineData}`);
  } else {
    console.log(`Signature: ${tx.signature}`);
  }
});
```

---

### ఎన్‌విరాన్‌మెంట్ సెట్టింగ్స్

#### `setRpcUrl()`

| **పారామీటర్లు** | `url`: Solana RPC URL |
|----------------|--------------------------|
| **రిటర్న్** | ఏమీ లేదు (void) |

```typescript
import { setRpcUrl } from '@iqlabs-official/solana-sdk';

setRpcUrl('https://your-rpc.example.com');
```

---

## అడ్వాన్స్‌డ్ ఫంక్షన్లు

<Warning>
ఇవి లో-లెవల్ SDK ఫంక్షన్లు. సాధారణ వినియోగానికి అవసరం లేదు, కానీ కస్టమ్ ఫీచర్లు తయారు చేయడంలో లేదా డీబగ్గింగ్‌లో సహాయపడతాయి.
</Warning>

### రైటర్ ఫంక్షన్లు

#### `manageRowData()`

టేబుళ్లలో రో డేటాను నిర్వహించడానికి లో-లెవల్ ఫంక్షన్.

| **మాడ్యూల్** | `writer` |
|------------|----------|
| **యూజ్ కేస్** | కస్టమ్ రో నిర్వహణ, బ్యాచ్ ఆపరేషన్లు |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { manageRowData } = iqlabs.writer;

await manageRowData(connection, signer, {
  dbRootId: 'my-db',
  tableSeed: 'users',
  operation: 'update',
  rowData: JSON.stringify({ id: 1, name: 'Updated Name' })
});
```

---

### రీడర్ ఫంక్షన్లు

#### `readUserState()`

ఒక యూజర్ యొక్క UserState PDA ను చదుతుంది.

| **మాడ్యూల్** | `reader` |
|------------|----------|
| **యూజ్ కేస్** | ప్రొఫైల్ డేటా పొందడం, అప్‌లోడ్ కౌంట్‌లను చెక్ చేయడం |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { readUserState } = iqlabs.reader;

const userState = await readUserState(userPubkey);
console.log('Profile:', userState.profile);
console.log('Upload count:', userState.fileCount);
```

---

#### `readInventoryMetadata()`

యూజర్ ఇన్వెంటరీ (అప్‌లోడ్ చేసిన ఫైళ్లు)కి సంబంధించిన మెటాడేటాను చదుతుంది.

| **మాడ్యూల్** | `reader` |
|------------|----------|
| **యూజ్ కేస్** | మెటాడేటాతో ఫైళ్లను జాబితా చేయడం, ఫైల్ నిర్వహణ |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { readInventoryMetadata } = iqlabs.reader;

const metadata = await readInventoryMetadata(userPubkey);
metadata.forEach(item => {
  console.log(`File: ${item.name}, Size: ${item.size}, Signature: ${item.signature}`);
});
```

---

#### `getSessionPdaList()`

సెషన్ PDAs జాబితాను పొందుతుంది.

| **మాడ్యూల్** | `reader` |
|------------|----------|
| **యూజ్ కేస్** | సెషన్ నిర్వహణ, సక్రియ సెషన్‌ల ట్రాకింగ్ |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { getSessionPdaList } = iqlabs.reader;

const sessions = await getSessionPdaList(userPubkey);
sessions.forEach(session => {
  console.log(`Session PDA: ${session.pda}, Active: ${session.isActive}`);
});
```

---

### యుటిలిటీ ఫంక్షన్లు

#### `deriveDmSeed()`

రెండు యూజర్ల మధ్య డైరెక్ట్ మెసేజింగ్ (DM) కోసం నిర్ణీత సీడ్ను ఉత్పత్తి చేస్తుంది.

| **మాడ్యూల్** | `utils` / `reader` |
|------------|----------|
| **యూజ్ కేస్** | స్థిరమైన కనెక్షన్ IDలను సృష్టించడం, DM ఛానల్ సెటప్ |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { deriveDmSeed } = iqlabs.utils;

const seed1 = deriveDmSeed(walletA, walletB);
const seed2 = deriveDmSeed(walletB, walletA);
console.log(seed1 === seed2); // true
```

---

#### `toSeedBytes()`

స్ట్రింగ్ సీడ్ను PDA డెరివేషన్‌కి అవసరమైన బైట్ ఫార్మాట్‌కు మార్చుతుంది.

| **మాడ్యూల్** | `utils` |
|------------|----------|
| **యూజ్ కేస్** | కస్టమ్ PDA డెరివేషన్, లో-లెవల్ సీడ్ మానిప్యులేషన్ |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';
const { toSeedBytes } = iqlabs.utils;

const seedString = 'my-custom-seed';
const seedBytes = toSeedBytes(seedString);

const [pda, bump] = PublicKey.findProgramAddressSync(
  [seedBytes, otherSeed],
  programId
);
```
