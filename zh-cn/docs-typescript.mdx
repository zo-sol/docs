---
title: "开发者文档"
description: "IQLabs SDK 的核心概念与函数"
---

<Note>
本文档仍在完善中，将持续更新。
</Note>

## 安装

```bash
npm i @iqlabs-official/solana-sdk
```

---

## 核心概念

这是在使用 IQLabs SDK 之前需要了解的关键概念。

---

### 数据存储（Code In）

这是将任何数据（文件、文本、JSON）上链的方式。

#### 如何存储？

SDK 会根据数据大小选择最优方式：

- **小数据 (&lt; 900 bytes)**：立即存储，速度最快
- **中等数据 (&lt; 8.5 KB)**：拆分为多笔交易
- **大数据 (&gt;= 8.5 KB)**：并行上传以提升速度

#### 关键相关函数

- [`codeIn()`](#codein)：上传数据并获取交易 ID
- [`readCodeIn()`](#readcodein)：通过交易 ID 读取数据

---

### 用户状态 PDA

用于用户的链上资料账户。

#### 会存储什么？

- 资料信息（姓名、头像、简介等）
- 已上传文件数量
- 好友请求记录

<Note>
好友请求不会以值的形式存储在 PDA 中；它们以交易形式发送。
</Note>

#### 何时创建？

第一次调用 [`codeIn()`](#codein) 时会自动创建。无需额外设置，但第一个用户可能需要签名两次。

---

### 连接 PDA

管理两个用户之间关系（好友、消息等）的链上账户。

#### 可有哪些状态？

- **pending**：已发送好友请求但尚未接受
- **approved**：请求已接受，用户已连接
- **blocked**：一方已屏蔽另一方

<Warning>
被屏蔽的连接只能由屏蔽方解除。
</Warning>

#### 关键相关函数

- [`requestConnection()`](#requestconnection)：发送好友请求（创建 pending）
- [`manageConnection()`](#manageconnection)：接受/拒绝/屏蔽/解除屏蔽请求
- [`readConnection()`](#readconnection)：检查当前关系状态
- [`writeConnectionRow()`](#writeconnectionrow)：与已连接的好友交换消息/数据
- [`fetchUserConnections()`](#fetchuserconnections)：获取所有连接（发送与接收的好友请求）

---

### 数据库表

像数据库一样用表存储 JSON 数据。

#### 表如何创建？

没有专门的"创建表"函数。第一次通过 [`writeRow()`](#writerow) 写入会自动创建表。

<Note>
表由 `dbRootId` 与 `tableSeed`（表名）的组合唯一标识。
</Note>

#### 关键相关函数

- [`writeRow()`](#writerow)：添加新行（若不存在则创建表）
- [`readTableRows()`](#readtablerows)：读取表中的行
- [`getTablelistFromRoot()`](#gettablelistfromroot)：列出数据库中的所有表
- [`fetchInventoryTransactions()`](#fetchinventorytransactions)：列出已上传文件

---

## 函数详情

### 数据存储与读取

#### `codeIn()`

| **参数** | `input`：`{ connection, signer }` 对象<br/>`data`：要上传的数据（string 或 string[]）<br/>`filename`：可选的文件名（string）<br/>`method`：上传方式（number，默认：0）<br/>`filetype`：文件类型提示（string，默认：''）<br/>`onProgress`：可选的进度回调 `(percent: number) => void` |
|----------------|--------------------------|
| **返回** | 交易签名（string） |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 上传数据
const signature = await iqlabs.writer.codeIn(
  { connection, signer },
  'Hello, blockchain!'
);

// 上传并指定文件名
const sig = await iqlabs.writer.codeIn(
  { connection, signer },
  'file contents here',
  'hello.txt'
);
```

---

#### `readCodeIn()`

| **参数** | `txSignature`：交易签名（string）<br/>`speed`：速率限制配置（可选，'light' \| 'medium' \| 'heavy' \| 'extreme'）<br/>`onProgress`：可选的进度回调 `(percent: number) => void` |
|----------------|--------------------------|
| **返回** | `{ metadata: string, data: string \| null }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.readCodeIn('5Xg7...');
console.log(result.data);      // 'Hello, blockchain!'
console.log(result.metadata);  // 包含文件元数据的 JSON 字符串
```

---

### 连接管理

#### `requestConnection()`

| **参数** | `connection`：Solana RPC 连接<br/>`signer`：签名者<br/>`dbRootId`：数据库 ID（Uint8Array 或 string）<br/>`partyA`：第一个用户公钥（string）<br/>`partyB`：第二个用户公钥（string）<br/>`tableName`：连接表名称（string 或 Uint8Array）<br/>`columns`：列列表（Array\<string \| Uint8Array\>）<br/>`idCol`：ID 列（string 或 Uint8Array）<br/>`extKeys`：扩展键（Array\<string \| Uint8Array\>） |
|----------------|--------------------------|
| **返回** | 交易签名（string） |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.requestConnection(
  connection, signer, 'my-db',
  myWalletAddress, friendWalletAddress,
  'dm_table', ['message', 'timestamp'], 'message_id', []
);
```

---

#### `manageConnection()`

<Note>
此函数没有高级 SDK 封装。请直接使用合约级指令构建器。
</Note>

| **参数** | `builder`：InstructionBuilder<br/>`accounts`：`{ db_root, connection_table, signer }`（PublicKey）<br/>`args`：`{ db_root_id, connection_seed, new_status }` |
|----------------|--------------------------|
| **返回** | TransactionInstruction |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const builder = iqlabs.contract.createInstructionBuilder(iqlabs.contract.PROGRAM_ID);

// 接受好友请求
const approveIx = iqlabs.contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: iqlabs.contract.CONNECTION_STATUS_APPROVED }
);

// 屏蔽用户
const blockIx = iqlabs.contract.manageConnectionInstruction(
  builder,
  { db_root, connection_table, signer: myPubkey },
  { db_root_id, connection_seed, new_status: iqlabs.contract.CONNECTION_STATUS_BLOCKED }
);
```

---

#### `readConnection()`

| **参数** | `dbRootId`：数据库 ID（Uint8Array 或 string）<br/>`partyA`：第一个钱包（string）<br/>`partyB`：第二个钱包（string） |
|----------------|--------------------------|
| **返回** | `{ status: 'pending' \| 'approved' \| 'blocked' \| 'unknown', requester: 'a' \| 'b', blocker: 'a' \| 'b' \| 'none' }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const { status, requester, blocker } = await iqlabs.reader.readConnection('my-db', partyA, partyB);
console.log(status); // 'pending' | 'approved' | 'blocked'
```

---

#### `writeConnectionRow()`

| **参数** | `connection`：Solana RPC 连接<br/>`signer`：签名者<br/>`dbRootId`：数据库 ID（Uint8Array 或 string）<br/>`connectionSeed`：连接种子（Uint8Array 或 string）<br/>`rowJson`：JSON 数据（string） |
|----------------|--------------------------|
| **返回** | 交易签名（string） |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.writeConnectionRow(
  connection, signer, 'my-db', connectionSeed,
  JSON.stringify({ message_id: '123', message: 'Hello friend!', timestamp: Date.now() })
);
```

---

#### `fetchUserConnections()`

通过分析 UserState PDA 的交易历史来获取用户的所有连接（好友请求）。每个连接包含其 `dbRootId`，用于标识该连接所属的应用。

| **参数** | `userPubkey`：用户公钥（string 或 PublicKey）<br/>`options`：可选设置 |
|----------------|--------------------------|
| **选项** | `limit`：最多获取的交易数<br/>`before`：用于分页的起始签名<br/>`speed`：速率限制配置（'light' \| 'medium' \| 'heavy' \| 'extreme'） |
| **返回** | 包含 `{ dbRootId, connectionPda, partyA, partyB, status, requester, blocker, timestamp }` 的数组 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const connections = await iqlabs.reader.fetchUserConnections(myPubkey, {
  speed: 'light',
  limit: 100
});

// 按状态过滤
const pendingRequests = connections.filter(c => c.status === 'pending');
const friends = connections.filter(c => c.status === 'approved');
const blocked = connections.filter(c => c.status === 'blocked');

// 查看连接详情
connections.forEach(conn => {
  console.log(`${conn.partyA} <-> ${conn.partyB}, status: ${conn.status}`);
});
```

---

### 表管理

#### `writeRow()`

| **参数** | `connection`：Solana RPC 连接<br/>`signer`：签名者<br/>`dbRootId`：数据库 ID（Uint8Array 或 string）<br/>`tableSeed`：表名（Uint8Array 或 string）<br/>`rowJson`：JSON 行数据（string）<br/>`skipConfirmation`：跳过交易确认（boolean，默认：false） |
|----------------|--------------------------|
| **返回** | 交易签名（string） |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 写入第一行以创建表
await iqlabs.writer.writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 1, name: 'Alice', email: 'alice@example.com'
}));

// 向同一张表添加另一行
await iqlabs.writer.writeRow(connection, signer, 'my-db', 'users', JSON.stringify({
  id: 2, name: 'Bob', email: 'bob@example.com'
}));
```

---

#### `readTableRows()`

| **参数** | `account`：表 PDA（PublicKey 或 string）<br/>`options`：可选设置 |
|----------------|--------------------------|
| **选项** | `limit`：最多获取的行数<br/>`before`：用于分页的签名游标<br/>`signatures`：预收集的签名数组（提供后跳过 RPC 获取）<br/>`speed`：速率限制配置（'light'、'medium'、'heavy'、'extreme'） |
| **返回** | `Array<Record<string, unknown>>` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 基本用法
const rows = await iqlabs.reader.readTableRows(tablePda, { limit: 50 });

// 基于游标的分页
const olderRows = await iqlabs.reader.readTableRows(tablePda, { limit: 50, before: 'sig...' });

// 使用预收集的签名（跳过签名获取，直接解码）
const sigs = await iqlabs.reader.collectSignatures(tablePda);
const targetIdx = sigs.indexOf('abc123');
const slice = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: slice });
```

---

#### `collectSignatures()`

收集账户的所有（或最多 `maxSignatures` 个）交易签名。轻量级 -- 不解码交易，只返回签名字符串。适用于分页：一次获取完整签名列表，然后切片传递给 `readTableRows()`。

| **参数** | `account`：表 PDA（PublicKey 或 string）<br/>`maxSignatures`：最多收集的签名数量（可选，省略则获取全部） |
|----------------|--------------------------|
| **返回** | `string[]`（签名字符串） |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

// 收集所有签名
const allSigs = await iqlabs.reader.collectSignatures(tablePda);

// 收集最多 3000 个签名
const sigs = await iqlabs.reader.collectSignatures(tablePda, 3000);

// 与 readTableRows 配合使用，从中间位置读取
const targetIdx = sigs.indexOf('abc123');
const chunk = sigs.slice(targetIdx - 25, targetIdx + 25);
const rows = await iqlabs.reader.readTableRows(tablePda, { signatures: chunk });
```

---

#### `getTablelistFromRoot()`

| **参数** | `connection`：Solana RPC 连接<br/>`dbRootId`：数据库 ID（Uint8Array 或 string） |
|----------------|--------------------------|
| **返回** | `{ rootPda: PublicKey, creator: string \| null, tableSeeds: string[], globalTableSeeds: string[] }` |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.getTablelistFromRoot(connection, 'my-db');
console.log('Creator:', result.creator);
console.log('Table seeds:', result.tableSeeds);
```

---

#### `fetchInventoryTransactions()`

| **参数** | `publicKey`：用户公钥（PublicKey）<br/>`limit`：最大数量（number）<br/>`before`：分页游标（可选，string） |
|----------------|--------------------------|
| **返回** | 交易数组 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const myFiles = await iqlabs.reader.fetchInventoryTransactions(myPubkey, 20);
myFiles.forEach(tx => {
  let metadata: { data?: unknown } | null = null;
  try {
    metadata = JSON.parse(tx.metadata);
  } catch {
    metadata = null;
  }

  if (metadata && metadata.data !== undefined) {
    const inlineData = typeof metadata.data === 'string'
      ? metadata.data
      : JSON.stringify(metadata.data);
    console.log(`Inline data: ${inlineData}`);
  } else {
    console.log(`Signature: ${tx.signature}`);
  }
});
```

---

### 环境设置

#### `setRpcUrl()`

| **参数** | `url`：Solana RPC URL（string） |
|----------------|--------------------------|
| **返回** | 无（void） |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

iqlabs.utils.setRpcUrl('https://your-rpc.example.com');
```

---

## 高级函数

<Warning>
这些是低级 SDK 函数。一般使用不需要，但在构建自定义功能或调试时很有用。
</Warning>

### 写入函数

#### `manageRowData()`

统一处理表行写入和连接行写入的函数。根据现有 PDA 自动检测是写入表还是连接。

| **模块** | `writer` |
|------------|----------|
| **参数** | `connection`：Solana RPC 连接<br/>`signer`：签名者<br/>`dbRootId`：数据库 ID（Uint8Array 或 string）<br/>`seed`：表或连接种子（Uint8Array 或 string）<br/>`rowJson`：JSON 行数据（string）<br/>`tableName`：表编辑时必需（可选，string 或 Uint8Array）<br/>`targetTx`：表编辑的引用交易（可选，string 或 Uint8Array） |
| **返回** | 交易签名（string） |
| **用途** | 自定义行管理、更新现有行 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

await iqlabs.writer.manageRowData(
  connection, signer,
  'my-db',       // dbRootId
  'users',       // seed（表种子）
  JSON.stringify({ id: 1, name: 'Updated Name' }),
  'users',       // tableName
  originalTxSig  // targetTx
);
```

---

### 读取函数

#### `readUserState()`

读取指定用户的 UserState PDA。

| **模块** | `reader` |
|------------|----------|
| **参数** | `userPubkey`：用户公钥（string） |
| **返回** | `{ owner: string, metadata: string \| null, totalSessionFiles: bigint, profileData?: string }` |
| **用途** | 获取用户资料数据、检查上传数量 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const userState = await iqlabs.reader.readUserState(userPubkey);
console.log('Owner:', userState.owner);
console.log('Session files:', userState.totalSessionFiles);
console.log('Profile data:', userState.profileData);
```

---

#### `readInventoryMetadata()`

读取与用户库存交易相关的元数据。

| **模块** | `reader` |
|------------|----------|
| **参数** | `txSignature`：交易签名（string） |
| **返回** | `{ onChainPath: string, metadata: string }` |
| **用途** | 从库存交易中提取文件元数据 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const result = await iqlabs.reader.readInventoryMetadata(txSignature);
console.log('Path:', result.onChainPath);
console.log('Metadata:', result.metadata);
```

---

#### `getSessionPdaList()`

获取用户的会话 PDA 地址列表。

| **模块** | `reader` |
|------------|----------|
| **参数** | `userPubkey`：用户公钥（string） |
| **返回** | `string[]`（会话 PDA base58 字符串） |
| **用途** | 会话管理、活跃会话跟踪 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const sessions = await iqlabs.reader.getSessionPdaList(userPubkey);
sessions.forEach(pda => {
  console.log(`Session PDA: ${pda}`);
});
```

---

### 工具函数

#### `deriveDmSeed()`

为两个用户之间的私信（DM）派生确定性种子。按字母顺序排列两个公钥并使用 keccak256 哈希。

| **模块** | `utils` |
|------------|----------|
| **参数** | `userA`：第一个用户公钥（string）<br/>`userB`：第二个用户公钥（string） |
| **返回** | `Uint8Array`（种子字节） |
| **用途** | 创建一致的连接标识、设置 DM 通道 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const seed1 = iqlabs.utils.deriveDmSeed(walletA, walletB);
const seed2 = iqlabs.utils.deriveDmSeed(walletB, walletA);
// seed1 和 seed2 完全相同 -- 顺序无关
```

---

#### `toSeedBytes()`

将种子标识符转换为字节。如果输入是 64 字符的十六进制字符串，则直接返回十六进制字节。否则应用 keccak256 哈希。

| **模块** | `utils` |
|------------|----------|
| **参数** | `value`：种子字符串或 Uint8Array |
| **返回** | `Uint8Array` |
| **用途** | 自定义 PDA 派生、低级种子操作 |

```typescript
import iqlabs from '@iqlabs-official/solana-sdk';

const seedString = 'my-custom-seed';
const seedBytes = iqlabs.utils.toSeedBytes(seedString);

const [pda, bump] = PublicKey.findProgramAddressSync(
  [seedBytes, otherSeed],
  programId
);
```
