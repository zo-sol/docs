---
title: "开发者文档（Python）"
description: "IQLabs Python SDK 的核心概念与函数"
---

<Note>
本文档正在编写中，后续将持续完善。
</Note>

## 安装

```bash
pip install iqlabs-solana-sdk
```

---

## 核心概念

以下是使用 IQLabs SDK 之前需要了解的关键概念。

---

### 数据存储（Code In）

这是将任意数据（文件、文本、JSON）存储到链上的方式。

#### 数据如何存储？

根据数据大小，SDK 会自动选择最优方式：

- **小数据（&lt; 850 字节）**：立即存储，速度最快
- **中等数据（&lt; 8.5 KB）**：拆分为多笔交易
- **大数据（&gt;= 8.5 KB）**：并行上传以提高速度

#### 关键相关函数

- [`code_in()`](#code_in)：上传数据并获取交易 ID
- [`read_code_in()`](#read_code_in)：通过交易 ID 读取数据

---

### 用户状态 PDA

链上的用户个人资料账户。

#### 存储了哪些内容？

- 个人资料信息（姓名、头像、简介等）
- 已上传文件数量
- 好友请求记录

<Note>
好友请求不是作为值存储在 PDA 中的，而是以交易的形式发送的。
</Note>

#### 何时创建？

首次调用 [`code_in()`](#code_in) 时会自动创建。无需额外设置，但首次用户可能需要签名两次。

---

### 连接 PDA

链上管理两个用户之间关系（好友、消息等）的账户。

#### 有哪些状态？

- **pending（待处理）**：好友请求已发送但尚未被接受
- **approved（已批准）**：请求已被接受，用户已建立连接
- **blocked（已屏蔽）**：一方屏蔽了另一方

<Warning>
被屏蔽的连接只能由屏蔽者解除屏蔽。
</Warning>

#### 关键相关函数

- [`request_connection()`](#request_connection)：发送好友请求（创建 pending 状态）
- [`manage_connection()`](#manage_connection)：批准/拒绝/屏蔽/解除屏蔽请求
- [`read_connection()`](#read_connection)：查询当前关系状态
- [`write_connection_row()`](#write_connection_row)：与已连接的好友交换消息/数据
- [`fetch_user_connections()`](#fetch_user_connections)：获取所有连接（已发送和已接收的好友请求）

---

### 数据库表

以类似数据库的表格形式存储 JSON 数据。

#### 表是如何创建的？

没有专门的"创建表"函数。通过 [`write_row()`](#write_row) 首次写入时会自动创建表。

<Note>
表由 `db_root_id` 和 `table_seed`（表名）的组合唯一标识。
</Note>

#### 关键相关函数

- [`write_row()`](#write_row)：添加新行（如果表不存在则自动创建）
- [`read_table_rows()`](#read_table_rows)：从表中读取行
- [`get_tablelist_from_root()`](#get_tablelist_from_root)：列出数据库中的所有表
- [`fetch_inventory_transactions()`](#fetch_inventory_transactions)：列出已上传的文件

---

## 函数详情

### 数据存储与检索

#### `code_in()`

| **参数** | `connection`：Solana RPC AsyncClient<br/>`signer`：Keypair 或 WalletSigner<br/>`chunks`：要上传的数据（list[str]）<br/>`filename`：可选文件名（str 或 None）<br/>`method`：上传方式（int，默认值：0）<br/>`filetype`：文件类型提示（str，默认值：''）<br/>`on_progress`：可选进度回调（Callable[[int], None]） |
|----------------|--------------------------|
| **返回值** | 交易签名（str） |

```python
from iqlabs import writer
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair

# 上传数据
signature = await writer.code_in(connection, signer, ['Hello, blockchain!'])

# 带文件名上传
signature = await writer.code_in(connection, signer, ['file contents here'], filename='hello.txt')
```

---

#### `read_code_in()`

| **参数** | `tx_signature`：交易签名（str）<br/>`speed`：速率限制配置（可选，str）<br/>`on_progress`：可选进度回调（Callable[[int], None]） |
|----------------|--------------------------|
| **返回值** | 包含 `metadata`（str）和 `data`（str 或 None）的字典 |

```python
from iqlabs import reader

result = await reader.read_code_in('5Xg7...')
print(result['data'])      # 'Hello, blockchain!'
print(result['metadata'])  # 包含文件元数据的 JSON 字符串
```

---

### 连接管理

#### `request_connection()`

| **参数** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：数据库 ID（bytes 或 str）<br/>`party_a`：第一个用户公钥（str）<br/>`party_b`：第二个用户公钥（str）<br/>`table_name`：连接表名（str 或 bytes）<br/>`columns`：列列表（list[str 或 bytes]）<br/>`id_col`：ID 列（str 或 bytes）<br/>`ext_keys`：扩展键（list[str 或 bytes]） |
|----------------|--------------------------|
| **返回值** | 交易签名（str） |

```python
from iqlabs import writer

await writer.request_connection(
    connection, signer, 'my-db',
    my_wallet_address, friend_wallet_address,
    'dm_table', ['message', 'timestamp'], 'message_id', []
)
```

---

#### `manage_connection()`

<Note>
此函数没有高级 SDK 封装。请直接使用合约级别的指令构建器。
</Note>

| **参数** | `builder`：InstructionBuilder<br/>`accounts`：包含 `db_root`、`connection_table`、`signer` 的字典<br/>`args`：包含 `db_root_id`、`connection_seed`、`new_status` 的字典 |
|----------------|--------------------------|
| **返回值** | Instruction |

```python
from iqlabs import contract

# 创建指令构建器
builder = contract.create_instruction_builder(contract.get_program_id())

# 批准好友请求
approve_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_APPROVED}
)

# 屏蔽用户
block_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_BLOCKED}
)
```

---

#### `read_connection()`

| **参数** | `db_root_id`：数据库 ID（bytes 或 str）<br/>`party_a`：第一个钱包（str）<br/>`party_b`：第二个钱包（str） |
|----------------|--------------------------|
| **返回值** | 包含 `status`、`requester`、`blocker` 的字典 |

```python
from iqlabs import reader

conn_info = await reader.read_connection('my-db', party_a, party_b)
print(conn_info['status'])  # 'pending' | 'approved' | 'blocked'
```

---

#### `write_connection_row()`

| **参数** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：数据库 ID（bytes 或 str）<br/>`connection_seed`：连接种子（bytes 或 str）<br/>`row_json`：JSON 数据（str） |
|----------------|--------------------------|
| **返回值** | 交易签名（str） |

```python
from iqlabs import writer
import json

await writer.write_connection_row(
    connection, signer, 'my-db', connection_seed,
    json.dumps({"message_id": "123", "message": "Hello friend!", "timestamp": 1234567890})
)
```

---

#### `fetch_user_connections()`

通过分析用户的 UserState PDA 交易历史，获取该用户的所有连接（好友请求）。每个连接都包含其 `db_root_id`，用于标识该连接所属的应用。

| **参数** | `user_pubkey`：用户公钥（str 或 Pubkey）<br/>`limit`：最大获取交易数（可选）<br/>`before`：用于分页的签名（可选）<br/>`speed`：速率限制配置（可选） |
|----------------|--------------------------|
| **返回值** | 连接字典列表，包含 db_root_id、connection_pda、party_a、party_b、status、requester、blocker、timestamp |

```python
from iqlabs import reader

# 获取所有连接（跨所有应用！）
connections = await reader.fetch_user_connections(
    my_pubkey,
    speed="light",
    limit=100
)

# 按状态筛选
pending_requests = [c for c in connections if c['status'] == 'pending']
friends = [c for c in connections if c['status'] == 'approved']
blocked = [c for c in connections if c['status'] == 'blocked']

# 查看连接详情
for conn in connections:
    print(f"Party A: {conn['party_a']} <-> Party B: {conn['party_b']}, status: {conn['status']}")
```

---

### 表管理

#### `write_row()`

| **参数** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：数据库 ID（bytes 或 str）<br/>`table_seed`：表名（bytes 或 str）<br/>`row_json`：JSON 行数据（str）<br/>`skip_confirmation`：跳过交易确认（默认值：False） |
|----------------|--------------------------|
| **返回值** | 交易签名（str） |

```python
from iqlabs import writer
import json

# 写入第一行以创建表
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 1, "name": "Alice", "email": "alice@example.com"
}))

# 向同一表添加另一行
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 2, "name": "Bob", "email": "bob@example.com"
}))
```

---

#### `read_table_rows()`

| **参数** | `account`：表 PDA（Pubkey 或 str）<br/>`before`：用于分页的签名游标（可选）<br/>`limit`：最大获取行数（可选）<br/>`speed`：速率限制配置（可选） |
|----------------|--------------------------|
| **返回值** | `list[dict]` |

```python
from iqlabs import reader

# 基本用法
rows = await reader.read_table_rows(table_pda, limit=50)

# 基于游标的分页
older_rows = await reader.read_table_rows(table_pda, limit=50, before="sig...")
```

---

#### `get_tablelist_from_root()`

| **参数** | `connection`：AsyncClient<br/>`db_root_id`：数据库 ID（bytes 或 str） |
|----------------|--------------------------|
| **返回值** | 包含 `root_pda`、`creator`、`table_seeds`、`global_table_seeds` 的字典 |

```python
from iqlabs import reader

result = await reader.get_tablelist_from_root(connection, 'my-db')
print('Creator:', result['creator'])
print('Table seeds:', result['table_seeds'])
```

---

#### `fetch_inventory_transactions()`

| **参数** | `public_key`：用户公钥（Pubkey）<br/>`limit`：最大数量（int）<br/>`before`：分页游标（可选，str） |
|----------------|--------------------------|
| **返回值** | 交易列表 |

```python
from iqlabs import reader
from solders.pubkey import Pubkey
import json

my_files = await reader.fetch_inventory_transactions(my_pubkey, 20)
for tx in my_files:
    metadata = None
    try:
        metadata = json.loads(tx['metadata'])
    except:
        metadata = None

    if metadata and 'data' in metadata:
        inline_data = metadata['data'] if isinstance(metadata['data'], str) else json.dumps(metadata['data'])
        print(f"Inline data: {inline_data}")
    else:
        print(f"Signature: {tx['signature']}")
```

---

### 环境设置

#### `set_rpc_url()`

| **参数** | `url`：Solana RPC URL（str） |
|----------------|--------------------------|
| **返回值** | None |

```python
from iqlabs import set_rpc_url

set_rpc_url('https://your-rpc.example.com')
```

---

## 高级函数

<Warning>
这些是底层 SDK 函数。常规使用中不需要，但在构建自定义功能或调试时会很有用。
</Warning>

### Writer 函数

#### `manage_row_data()`

统一处理表行写入和连接行写入的函数。根据现有 PDA 自动检测是写入表还是连接。

| **模块** | `writer` |
|------------|----------|
| **参数** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：数据库 ID（bytes 或 str）<br/>`seed`：表或连接种子（bytes 或 str）<br/>`row_json`：JSON 行数据（str）<br/>`table_name`：表编辑时必需（可选）<br/>`target_tx`：表编辑的参考交易（可选） |
| **返回值** | 交易签名（str） |
| **使用场景** | 自定义行管理、更新现有行 |

```python
from iqlabs import writer
import json

await writer.manage_row_data(
    connection, signer,
    'my-db',       # db_root_id
    'users',       # seed（表种子）
    json.dumps({"id": 1, "name": "Updated Name"}),
    table_name='users',
    target_tx=original_tx_sig
)
```

---

### Reader 函数

#### `read_user_state()`

读取指定用户的 UserState PDA。

| **模块** | `reader` |
|------------|----------|
| **参数** | `user_pubkey`：用户公钥（str） |
| **返回值** | 包含 `owner`、`metadata`、`total_session_files`、`profile_data` 的字典 |
| **使用场景** | 获取用户个人资料数据、查看上传数量 |

```python
from iqlabs import reader

user_state = await reader.read_user_state(user_pubkey)
print('Owner:', user_state['owner'])
print('Session files:', user_state['total_session_files'])
print('Profile data:', user_state['profile_data'])
```

---

#### `read_inventory_metadata()`

读取与用户库存交易关联的元数据。

| **模块** | `reader` |
|------------|----------|
| **参数** | `tx_signature`：交易签名（str） |
| **返回值** | 包含元数据的字典 |
| **使用场景** | 从库存交易中提取文件元数据 |

```python
from iqlabs import reader

result = await reader.read_inventory_metadata(tx_signature)
print('Metadata:', result)
```

---

#### `get_session_pda_list()`

获取用户的会话 PDA 地址列表。

| **模块** | `reader` |
|------------|----------|
| **参数** | `user_pubkey`：用户公钥（str） |
| **返回值** | `list[str]`（会话 PDA 的 base58 字符串） |
| **使用场景** | 会话管理、活跃会话追踪 |

```python
from iqlabs import reader

sessions = await reader.get_session_pda_list(user_pubkey)
for pda in sessions:
    print(f"Session PDA: {pda}")
```

---

#### 合约 PDA 函数

`contract` 模块中提供的底层 PDA 派生函数。

| **模块** | `contract` |
|------------|----------|
| **使用场景** | 自定义 PDA 派生、账户查找 |

```python
from iqlabs import contract
from solders.pubkey import Pubkey

program_id = contract.get_program_id()
db_root_pda = contract.get_db_root_pda(db_root_id, program_id)
table_pda = contract.get_table_pda(db_root_pda, table_seed, program_id)
user_pda = contract.get_user_pda(user_pubkey, program_id)
session_pda = contract.get_session_pda(user_pubkey, seq=0, program_id=program_id)
connection_pda = contract.get_connection_table_pda(db_root_pda, connection_seed, program_id)
```

---

### 实用工具函数

#### `derive_dm_seed()`

为两个用户之间的私信（DM）派生确定性种子。将两个公钥按字母顺序排序，并使用 Keccak-256 对 `"lower:upper"` 进行哈希。

| **模块** | `utils` |
|------------|----------|
| **参数** | `user_a`：第一个用户公钥（str）<br/>`user_b`：第二个用户公钥（str） |
| **返回值** | bytes（32 字节种子） |
| **使用场景** | 创建一致的连接标识符、私信通道设置 |

```python
from iqlabs.sdk.utils.seed import derive_dm_seed

seed1 = derive_dm_seed(wallet_a, wallet_b)
seed2 = derive_dm_seed(wallet_b, wallet_a)
print(seed1 == seed2)  # True — 顺序无关
```

---

#### `to_seed_bytes()`

将种子标识符转换为字节。如果输入是 64 字符的十六进制字符串，则直接透传。否则，应用 Keccak-256 哈希。

| **模块** | `utils` |
|------------|----------|
| **参数** | `value`：种子字符串或字节 |
| **返回值** | bytes |
| **使用场景** | 自定义 PDA 派生、底层种子操作 |

```python
from iqlabs.sdk.utils.seed import to_seed_bytes
from solders.pubkey import Pubkey

seed_string = 'my-custom-seed'
seed_bytes = to_seed_bytes(seed_string)

pda, bump = Pubkey.find_program_address(
    [seed_bytes, other_seed],
    program_id
)
```

---
