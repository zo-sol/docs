---
title: "開発者ドキュメント（Python）"
description: "IQLabs Python SDKのコアコンセプトと関数"
---

<Note>
このドキュメントは作成中であり、今後改善される予定です。
</Note>

## インストール

```bash
pip install iqlabs-solana-sdk
```

---

## コアコンセプト

IQLabs SDKを使用する前に知っておくべき主要なコンセプトです。

---

### データストレージ（Code In）

任意のデータ（ファイル、テキスト、JSON）をオンチェーンに保存する方法です。

#### どのように保存されますか？

データサイズに応じて、SDKが最適な方法を自動的に選択します：

- **小さいデータ（&lt; 850バイト）**：即座に保存、最速
- **中程度のデータ（&lt; 8.5 KB）**：複数のトランザクションに分割
- **大きいデータ（&gt;= 8.5 KB）**：高速化のため並列アップロード

#### 関連する主要関数

- [`code_in()`](#code_in)：データをアップロードしてトランザクションIDを取得
- [`read_code_in()`](#read_code_in)：トランザクションIDからデータを読み取る

---

### ユーザーステートPDA

ユーザーのオンチェーンプロフィールアカウントです。

#### 何が保存されますか？

- プロフィール情報（名前、プロフィール画像、自己紹介など）
- アップロードされたファイルの数
- フレンドリクエストの記録

<Note>
フレンドリクエストはPDA内に値として保存されるのではなく、トランザクションとして送信されます。
</Note>

#### いつ作成されますか？

[`code_in()`](#code_in)を初めて呼び出した際に自動的に作成されます。追加のセットアップは不要ですが、初回のユーザーは2回署名が必要になる場合があります。

---

### コネクションPDA

2人のユーザー間の関係（フレンド、メッセージなど）を管理するオンチェーンアカウントです。

#### どのような状態がありますか？

- **pending（保留中）**：フレンドリクエストが送信されたが、まだ承認されていない
- **approved（承認済み）**：リクエストが承認され、ユーザー同士が接続された
- **blocked（ブロック済み）**：一方が相手をブロックした

<Warning>
ブロックされたコネクションは、ブロックした側のみがブロック解除できます。
</Warning>

#### 関連する主要関数

- [`request_connection()`](#request_connection)：フレンドリクエストを送信（pending状態を作成）
- [`manage_connection()`](#manage_connection)：リクエストの承認/拒否/ブロック/ブロック解除
- [`read_connection()`](#read_connection)：現在の関係ステータスを確認
- [`write_connection_row()`](#write_connection_row)：接続済みのフレンドとメッセージ/データを交換
- [`fetch_user_connections()`](#fetch_user_connections)：すべてのコネクション（送受信したフレンドリクエスト）を取得

---

### データベーステーブル

JSONデータをデータベースのようにテーブルに保存します。

#### テーブルはどのように作成されますか？

専用の「テーブル作成」関数はありません。[`write_row()`](#write_row)による最初の書き込み時にテーブルが自動的に作成されます。

<Note>
テーブルは`db_root_id`と`table_seed`（テーブル名）の組み合わせで一意に識別されます。
</Note>

#### 関連する主要関数

- [`write_row()`](#write_row)：新しい行を追加（テーブルが存在しない場合は自動作成）
- [`read_table_rows()`](#read_table_rows)：テーブルから行を読み取る
- [`get_tablelist_from_root()`](#get_tablelist_from_root)：データベース内のすべてのテーブルを一覧表示
- [`fetch_inventory_transactions()`](#fetch_inventory_transactions)：アップロードされたファイルを一覧表示

---

## 関数の詳細

### データの保存と取得

#### `code_in()`

| **パラメータ** | `connection`：Solana RPC AsyncClient<br/>`signer`：KeypairまたはWalletSigner<br/>`chunks`：アップロードするデータ（list[str]）<br/>`filename`：オプションのファイル名（strまたはNone）<br/>`method`：アップロード方法（int、デフォルト：0）<br/>`filetype`：ファイルタイプのヒント（str、デフォルト：''）<br/>`on_progress`：オプションの進捗コールバック（Callable[[int], None]） |
|----------------|--------------------------|
| **戻り値** | トランザクション署名（str） |

```python
from iqlabs import writer
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair

# データをアップロード
signature = await writer.code_in(connection, signer, ['Hello, blockchain!'])

# ファイル名付きでアップロード
signature = await writer.code_in(connection, signer, ['file contents here'], filename='hello.txt')
```

---

#### `read_code_in()`

| **パラメータ** | `tx_signature`：トランザクション署名（str）<br/>`speed`：レートリミットプロファイル（オプション、str）<br/>`on_progress`：オプションの進捗コールバック（Callable[[int], None]） |
|----------------|--------------------------|
| **戻り値** | `metadata`（str）と`data`（strまたはNone）を含む辞書 |

```python
from iqlabs import reader

result = await reader.read_code_in('5Xg7...')
print(result['data'])      # 'Hello, blockchain!'
print(result['metadata'])  # ファイルメタデータを含むJSON文字列
```

---

### コネクション管理

#### `request_connection()`

| **パラメータ** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：データベースID（bytesまたはstr）<br/>`party_a`：1人目のユーザーの公開鍵（str）<br/>`party_b`：2人目のユーザーの公開鍵（str）<br/>`table_name`：コネクションテーブル名（strまたはbytes）<br/>`columns`：カラムリスト（list[strまたはbytes]）<br/>`id_col`：IDカラム（strまたはbytes）<br/>`ext_keys`：拡張キー（list[strまたはbytes]） |
|----------------|--------------------------|
| **戻り値** | トランザクション署名（str） |

```python
from iqlabs import writer

await writer.request_connection(
    connection, signer, 'my-db',
    my_wallet_address, friend_wallet_address,
    'dm_table', ['message', 'timestamp'], 'message_id', []
)
```

---

#### `manage_connection()`

<Note>
この関数にはハイレベルのSDKラッパーがありません。コントラクトレベルのインストラクションビルダーを直接使用してください。
</Note>

| **パラメータ** | `builder`：InstructionBuilder<br/>`accounts`：`db_root`、`connection_table`、`signer`を含む辞書<br/>`args`：`db_root_id`、`connection_seed`、`new_status`を含む辞書 |
|----------------|--------------------------|
| **戻り値** | インストラクション |

```python
from iqlabs import contract

# インストラクションビルダーを作成
builder = contract.create_instruction_builder(contract.get_program_id())

# フレンドリクエストを承認
approve_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_APPROVED}
)

# ユーザーをブロック
block_ix = contract.manage_connection_instruction(
    builder,
    {"db_root": db_root, "connection_table": connection_table, "signer": my_pubkey},
    {"db_root_id": db_root_id, "connection_seed": connection_seed, "new_status": contract.CONNECTION_STATUS_BLOCKED}
)
```

---

#### `read_connection()`

| **パラメータ** | `db_root_id`：データベースID（bytesまたはstr）<br/>`party_a`：1人目のウォレット（str）<br/>`party_b`：2人目のウォレット（str） |
|----------------|--------------------------|
| **戻り値** | `status`、`requester`、`blocker`を含む辞書 |

```python
from iqlabs import reader

conn_info = await reader.read_connection('my-db', party_a, party_b)
print(conn_info['status'])  # 'pending' | 'approved' | 'blocked'
```

---

#### `write_connection_row()`

| **パラメータ** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：データベースID（bytesまたはstr）<br/>`connection_seed`：コネクションシード（bytesまたはstr）<br/>`row_json`：JSONデータ（str） |
|----------------|--------------------------|
| **戻り値** | トランザクション署名（str） |

```python
from iqlabs import writer
import json

await writer.write_connection_row(
    connection, signer, 'my-db', connection_seed,
    json.dumps({"message_id": "123", "message": "Hello friend!", "timestamp": 1234567890})
)
```

---

#### `fetch_user_connections()`

ユーザーのUserState PDAトランザクション履歴を分析して、そのユーザーのすべてのコネクション（フレンドリクエスト）を取得します。各コネクションには`db_root_id`が含まれており、そのコネクションがどのアプリに属しているかを識別します。

| **パラメータ** | `user_pubkey`：ユーザーの公開鍵（strまたはPubkey）<br/>`limit`：取得するトランザクションの最大数（オプション）<br/>`before`：ページネーション用の署名（オプション）<br/>`speed`：レートリミットプロファイル（オプション） |
|----------------|--------------------------|
| **戻り値** | db_root_id、connection_pda、party_a、party_b、status、requester、blocker、timestampを含むコネクション辞書のリスト |

```python
from iqlabs import reader

# すべてのコネクションを取得（すべてのアプリにまたがる！）
connections = await reader.fetch_user_connections(
    my_pubkey,
    speed="light",
    limit=100
)

# ステータスでフィルタリング
pending_requests = [c for c in connections if c['status'] == 'pending']
friends = [c for c in connections if c['status'] == 'approved']
blocked = [c for c in connections if c['status'] == 'blocked']

# コネクションの詳細を確認
for conn in connections:
    print(f"Party A: {conn['party_a']} <-> Party B: {conn['party_b']}, status: {conn['status']}")
```

---

### テーブル管理

#### `write_row()`

| **パラメータ** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：データベースID（bytesまたはstr）<br/>`table_seed`：テーブル名（bytesまたはstr）<br/>`row_json`：JSON行データ（str）<br/>`skip_confirmation`：トランザクション確認をスキップ（デフォルト：False） |
|----------------|--------------------------|
| **戻り値** | トランザクション署名（str） |

```python
from iqlabs import writer
import json

# 最初の行を書き込んでテーブルを作成
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 1, "name": "Alice", "email": "alice@example.com"
}))

# 同じテーブルに別の行を追加
await writer.write_row(connection, signer, 'my-db', 'users', json.dumps({
    "id": 2, "name": "Bob", "email": "bob@example.com"
}))
```

---

#### `read_table_rows()`

| **パラメータ** | `account`：テーブルPDA（Pubkeyまたはstr）<br/>`before`：ページネーション用の署名カーソル（オプション）<br/>`limit`：取得する行の最大数（オプション）<br/>`speed`：レートリミットプロファイル（オプション） |
|----------------|--------------------------|
| **戻り値** | `list[dict]` |

```python
from iqlabs import reader

# 基本的な使い方
rows = await reader.read_table_rows(table_pda, limit=50)

# カーソルベースのページネーション
older_rows = await reader.read_table_rows(table_pda, limit=50, before="sig...")
```

---

#### `get_tablelist_from_root()`

| **パラメータ** | `connection`：AsyncClient<br/>`db_root_id`：データベースID（bytesまたはstr） |
|----------------|--------------------------|
| **戻り値** | `root_pda`、`creator`、`table_seeds`、`global_table_seeds`を含む辞書 |

```python
from iqlabs import reader

result = await reader.get_tablelist_from_root(connection, 'my-db')
print('Creator:', result['creator'])
print('Table seeds:', result['table_seeds'])
```

---

#### `fetch_inventory_transactions()`

| **パラメータ** | `public_key`：ユーザーの公開鍵（Pubkey）<br/>`limit`：最大件数（int）<br/>`before`：ページネーションカーソル（オプション、str） |
|----------------|--------------------------|
| **戻り値** | トランザクションリスト |

```python
from iqlabs import reader
from solders.pubkey import Pubkey
import json

my_files = await reader.fetch_inventory_transactions(my_pubkey, 20)
for tx in my_files:
    metadata = None
    try:
        metadata = json.loads(tx['metadata'])
    except:
        metadata = None

    if metadata and 'data' in metadata:
        inline_data = metadata['data'] if isinstance(metadata['data'], str) else json.dumps(metadata['data'])
        print(f"Inline data: {inline_data}")
    else:
        print(f"Signature: {tx['signature']}")
```

---

### 環境設定

#### `set_rpc_url()`

| **パラメータ** | `url`：Solana RPC URL（str） |
|----------------|--------------------------|
| **戻り値** | None |

```python
from iqlabs import set_rpc_url

set_rpc_url('https://your-rpc.example.com')
```

---

## 高度な関数

<Warning>
これらは低レベルのSDK関数です。通常の使用では必要ありませんが、カスタム機能の構築やデバッグ時に役立ちます。
</Warning>

### ライター関数

#### `manage_row_data()`

テーブル行の書き込みとコネクション行の書き込みの両方を処理する統合関数です。既存のPDAに基づいて、テーブルへの書き込みかコネクションへの書き込みかを自動的に検出します。

| **モジュール** | `writer` |
|------------|----------|
| **パラメータ** | `connection`：AsyncClient<br/>`signer`：Keypair<br/>`db_root_id`：データベースID（bytesまたはstr）<br/>`seed`：テーブルまたはコネクションシード（bytesまたはstr）<br/>`row_json`：JSON行データ（str）<br/>`table_name`：テーブル編集時に必要（オプション）<br/>`target_tx`：テーブル編集用の参照トランザクション（オプション） |
| **戻り値** | トランザクション署名（str） |
| **ユースケース** | カスタム行管理、既存行の更新 |

```python
from iqlabs import writer
import json

await writer.manage_row_data(
    connection, signer,
    'my-db',       # db_root_id
    'users',       # seed（テーブルシード）
    json.dumps({"id": 1, "name": "Updated Name"}),
    table_name='users',
    target_tx=original_tx_sig
)
```

---

### リーダー関数

#### `read_user_state()`

指定されたユーザーのUserState PDAを読み取ります。

| **モジュール** | `reader` |
|------------|----------|
| **パラメータ** | `user_pubkey`：ユーザーの公開鍵（str） |
| **戻り値** | `owner`、`metadata`、`total_session_files`、`profile_data`を含む辞書 |
| **ユースケース** | ユーザープロフィールデータの取得、アップロード回数の確認 |

```python
from iqlabs import reader

user_state = await reader.read_user_state(user_pubkey)
print('Owner:', user_state['owner'])
print('Session files:', user_state['total_session_files'])
print('Profile data:', user_state['profile_data'])
```

---

#### `read_inventory_metadata()`

ユーザーのインベントリトランザクションに関連するメタデータを読み取ります。

| **モジュール** | `reader` |
|------------|----------|
| **パラメータ** | `tx_signature`：トランザクション署名（str） |
| **戻り値** | メタデータを含む辞書 |
| **ユースケース** | インベントリトランザクションからファイルメタデータを抽出 |

```python
from iqlabs import reader

result = await reader.read_inventory_metadata(tx_signature)
print('Metadata:', result)
```

---

#### `get_session_pda_list()`

ユーザーのセッションPDAアドレスのリストを取得します。

| **モジュール** | `reader` |
|------------|----------|
| **パラメータ** | `user_pubkey`：ユーザーの公開鍵（str） |
| **戻り値** | `list[str]`（セッションPDAのbase58文字列） |
| **ユースケース** | セッション管理、アクティブセッションの追跡 |

```python
from iqlabs import reader

sessions = await reader.get_session_pda_list(user_pubkey)
for pda in sessions:
    print(f"Session PDA: {pda}")
```

---

#### コントラクトPDA関数

`contract`モジュールで利用可能な低レベルのPDA導出関数です。

| **モジュール** | `contract` |
|------------|----------|
| **ユースケース** | カスタムPDA導出、アカウント検索 |

```python
from iqlabs import contract
from solders.pubkey import Pubkey

program_id = contract.get_program_id()
db_root_pda = contract.get_db_root_pda(db_root_id, program_id)
table_pda = contract.get_table_pda(db_root_pda, table_seed, program_id)
user_pda = contract.get_user_pda(user_pubkey, program_id)
session_pda = contract.get_session_pda(user_pubkey, seq=0, program_id=program_id)
connection_pda = contract.get_connection_table_pda(db_root_pda, connection_seed, program_id)
```

---

### ユーティリティ関数

#### `derive_dm_seed()`

2人のユーザー間のダイレクトメッセージ（DM）用の決定論的シードを導出します。2つの公開鍵をアルファベット順にソートし、`"lower:upper"`をKeccak-256でハッシュ化します。

| **モジュール** | `utils` |
|------------|----------|
| **パラメータ** | `user_a`：1人目のユーザーの公開鍵（str）<br/>`user_b`：2人目のユーザーの公開鍵（str） |
| **戻り値** | bytes（32バイトのシード） |
| **ユースケース** | 一貫したコネクション識別子の作成、DMチャンネルのセットアップ |

```python
from iqlabs.sdk.utils.seed import derive_dm_seed

seed1 = derive_dm_seed(wallet_a, wallet_b)
seed2 = derive_dm_seed(wallet_b, wallet_a)
print(seed1 == seed2)  # True — 順序は関係ありません
```

---

#### `to_seed_bytes()`

シード識別子をバイトに変換します。入力が64文字の16進数文字列の場合、そのまま通過します。それ以外の場合、Keccak-256ハッシュが適用されます。

| **モジュール** | `utils` |
|------------|----------|
| **パラメータ** | `value`：シード文字列またはbytes |
| **戻り値** | bytes |
| **ユースケース** | カスタムPDA導出、低レベルのシード操作 |

```python
from iqlabs.sdk.utils.seed import to_seed_bytes
from solders.pubkey import Pubkey

seed_string = 'my-custom-seed'
seed_bytes = to_seed_bytes(seed_string)

pda, bump = Pubkey.find_program_address(
    [seed_bytes, other_seed],
    program_id
)
```

---
